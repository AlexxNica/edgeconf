1
00:00:00,000 --> 00:00:06,150

2
00:00:06,150 --> 00:00:07,870
ANDRE BEHRENS: OK, so we're
gonna be talking about

3
00:00:07,870 --> 00:00:10,360
rendering performance, or as I
like to think of it, the war

4
00:00:10,360 --> 00:00:11,820
on purple and green.

5
00:00:11,820 --> 00:00:13,195
I'm sure you've engaged
in that yourselves

6
00:00:13,195 --> 00:00:15,340
from time to time.

7
00:00:15,340 --> 00:00:22,540
On our panel today, we have
Josh, Josh Peek from GitHub,

8
00:00:22,540 --> 00:00:25,880
Ariya Hidayat from Sencha.

9
00:00:25,880 --> 00:00:30,143
We have our opening speaker,
Jonathan Klein, from Etsy.

10
00:00:30,143 --> 00:00:32,409
We have Paul List from Google.

11
00:00:32,409 --> 00:00:34,390
And we have Eli Fidler
from BlackBerry.

12
00:00:34,390 --> 00:00:37,325
So let's just go in with
the presentation.

13
00:00:37,325 --> 00:00:38,000
You ready to go?

14
00:00:38,000 --> 00:00:39,250
JONATHAN KLEIN: I think so.

15
00:00:39,250 --> 00:00:42,100

16
00:00:42,100 --> 00:00:43,352
ANDRE BEHRENS: Can we get
the presentation up?

17
00:00:43,352 --> 00:00:48,860

18
00:00:48,860 --> 00:00:50,740
JONATHAN KLEIN: OK.

19
00:00:50,740 --> 00:00:52,296
When we talk about rendering
performance, we're really

20
00:00:52,296 --> 00:00:53,930
talking about this
number here.

21
00:00:53,930 --> 00:00:57,700
Most monitors and devices we
have today are rendering--

22
00:00:57,700 --> 00:00:59,700
ANDRE BEHRENS: Mic.

23
00:00:59,700 --> 00:01:00,400
JONATHAN KLEIN: Hey, that's
a lot better.

24
00:01:00,400 --> 00:01:01,680
Thanks.

25
00:01:01,680 --> 00:01:04,180
Most monitors and devices we
have today are rendering at

26
00:01:04,180 --> 00:01:05,635
about 60 frames per second.

27
00:01:05,635 --> 00:01:07,560
So when we talk about rendering
performance, we're

28
00:01:07,560 --> 00:01:10,410
really talking about trying to
get your application to render

29
00:01:10,410 --> 00:01:12,680
at 60 frames per second with
all animations, with

30
00:01:12,680 --> 00:01:15,160
scrolling, et cetera.

31
00:01:15,160 --> 00:01:17,700
If you do the math on this,
it means that we have 16.6

32
00:01:17,700 --> 00:01:20,900
milliseconds, approximately,
to get a paint event done.

33
00:01:20,900 --> 00:01:22,820
So any time you have a paint
event that's taking longer

34
00:01:22,820 --> 00:01:25,570
than that to render on your
page, you're going to get jank

35
00:01:25,570 --> 00:01:28,910
on the page, and it's
gonna be slow.

36
00:01:28,910 --> 00:01:31,420
Luckily, we have tools today
that make this pretty easy to

37
00:01:31,420 --> 00:01:32,780
see what's going on.

38
00:01:32,780 --> 00:01:34,370
This is an example of
Chrome DevTools.

39
00:01:34,370 --> 00:01:37,010
All you do is turn on the
continuous page repainting

40
00:01:37,010 --> 00:01:39,480
mode, and then in the upper
right section of the page,

41
00:01:39,480 --> 00:01:41,580
you'll get a nice meter that
tells you exactly how long the

42
00:01:41,580 --> 00:01:42,830
paints are taking.

43
00:01:42,830 --> 00:01:44,100
This is on the Edge
Conf website.

44
00:01:44,100 --> 00:01:46,920
You can see here 2.7
milliseconds for this paint

45
00:01:46,920 --> 00:01:48,540
event, and then there's a meter
on the right there that

46
00:01:48,540 --> 00:01:51,780
says it's ranging between
2.6 and 4.6.

47
00:01:51,780 --> 00:01:53,600
This is very, very
fast paints.

48
00:01:53,600 --> 00:01:57,340
If our budget is 16.6
milliseconds, then 2.7 is well

49
00:01:57,340 --> 00:01:59,130
within that budget.

50
00:01:59,130 --> 00:02:01,130
And as you scroll, the page
this meter will adjust,

51
00:02:01,130 --> 00:02:03,080
depending on how long the
paints are taking.

52
00:02:03,080 --> 00:02:06,830
So anytime you see this meter
spike above 16.6 milliseconds,

53
00:02:06,830 --> 00:02:09,130
you're gonna get that jank
that I talked about.

54
00:02:09,130 --> 00:02:11,090
And jank is something that
I'm sure we've all seen.

55
00:02:11,090 --> 00:02:14,210
It's basically when you're
scrolling a page and it hangs,

56
00:02:14,210 --> 00:02:16,540
or animation is happening,
and you can't scroll--

57
00:02:16,540 --> 00:02:19,270
any time where the page
performance drops below 60

58
00:02:19,270 --> 00:02:20,410
frames per second.

59
00:02:20,410 --> 00:02:22,240
And, again, this happens pretty
widely on the web

60
00:02:22,240 --> 00:02:24,730
today, and it's a pretty
big problem.

61
00:02:24,730 --> 00:02:30,300
And that's the term that's
been generated for it.

62
00:02:30,300 --> 00:02:32,220
What causes jank, now that
we know what it is?

63
00:02:32,220 --> 00:02:35,140
Well, this slide I pulled
directly from the Jank Busters

64
00:02:35,140 --> 00:02:36,845
Google I/O talk earlier
this year.

65
00:02:36,845 --> 00:02:39,340
And I think it gives a good
overview of the main things

66
00:02:39,340 --> 00:02:41,720
that are important
to think about.

67
00:02:41,720 --> 00:02:43,770
These things really fall
into two categories.

68
00:02:43,770 --> 00:02:47,570
So first is unnecessary
paints.

69
00:02:47,570 --> 00:02:49,800
So this is if you have, maybe
your paints are fast, but you

70
00:02:49,800 --> 00:02:51,090
have too many of them.

71
00:02:51,090 --> 00:02:53,420
So you try to jam hundreds
of paints into a

72
00:02:53,420 --> 00:02:54,290
single scroll event.

73
00:02:54,290 --> 00:02:55,940
And that's just not gonna
perform well, no matter what

74
00:02:55,940 --> 00:02:56,990
you're doing.

75
00:02:56,990 --> 00:02:59,590
And the other category is long
paints, so these are examples

76
00:02:59,590 --> 00:03:02,030
where you might have a single
paint event, but it takes more

77
00:03:02,030 --> 00:03:06,210
than your budget of 16
milliseconds to render.

78
00:03:06,210 --> 00:03:07,870
And there are some examples
here of different event

79
00:03:07,870 --> 00:03:10,530
handlers that can cause that
problem, CSS issues, and just

80
00:03:10,530 --> 00:03:13,550
visually complex pages.

81
00:03:13,550 --> 00:03:15,050
Why do we care about jank?

82
00:03:15,050 --> 00:03:16,780
Why do we care about rendering
performance in general?

83
00:03:16,780 --> 00:03:18,820
People have talked a lot
historically about page

84
00:03:18,820 --> 00:03:22,160
performance itself, but this
idea of rendering performance

85
00:03:22,160 --> 00:03:24,980
is fairly new.

86
00:03:24,980 --> 00:03:27,010
During Edge London earlier
this year, we heard Shane

87
00:03:27,010 --> 00:03:29,740
O'Sullivan say that Facebook
artificially lowered the frame

88
00:03:29,740 --> 00:03:33,110
rate on their iOS and Android
apps from 60 frames per second

89
00:03:33,110 --> 00:03:35,810
down to 30 frames per second,
and engagement collapsed,

90
00:03:35,810 --> 00:03:37,790
according to him.

91
00:03:37,790 --> 00:03:39,530
On a native app, it's
pretty easy to get

92
00:03:39,530 --> 00:03:41,130
60 frames per second.

93
00:03:41,130 --> 00:03:43,420
If you get down to 30,
that's pretty bad.

94
00:03:43,420 --> 00:03:45,860
So they artificially did this
to, he said, a small segment

95
00:03:45,860 --> 00:03:50,160
of the users, maybe a few dozen
million users, and it

96
00:03:50,160 --> 00:03:51,590
caused major problems.

97
00:03:51,590 --> 00:03:54,880
At Etsy, we did a similar test
in the sense that we started

98
00:03:54,880 --> 00:03:57,680
pre-fetching JavaScript on
our search results page.

99
00:03:57,680 --> 00:03:59,830
When the JavaScript came down
the pipe and was actually

100
00:03:59,830 --> 00:04:03,040
executed by the browser,
we got janky behaviors.

101
00:04:03,040 --> 00:04:05,200
So, essentially, you'd see in
the Chrome console that the

102
00:04:05,200 --> 00:04:07,600
JavaScript came in,
and then the page

103
00:04:07,600 --> 00:04:08,320
performance would degrade.

104
00:04:08,320 --> 00:04:10,520
You couldn't scroll the page,
and it was really nasty.

105
00:04:10,520 --> 00:04:12,560
We were monitoring all the
business metrics on this page

106
00:04:12,560 --> 00:04:15,270
when we were testing this change
out, and as soon as we

107
00:04:15,270 --> 00:04:17,160
rolled it out, the business
metrics got a lot

108
00:04:17,160 --> 00:04:18,470
worse across the board.

109
00:04:18,470 --> 00:04:19,980
So we'd rolled it back, and we
were unable to make that

110
00:04:19,980 --> 00:04:23,060
change with the current
implementation.

111
00:04:23,060 --> 00:04:26,880
And this is all to say that
right now, in many cases,

112
00:04:26,880 --> 00:04:28,770
rendering performance is more
important than full-page

113
00:04:28,770 --> 00:04:29,520
performance.

114
00:04:29,520 --> 00:04:31,970
If your page is fully loaded,
you might think OK, I'm done.

115
00:04:31,970 --> 00:04:33,230
It happened quickly,
that's fine.

116
00:04:33,230 --> 00:04:35,276
But if the user can't scroll and
interact with the page or

117
00:04:35,276 --> 00:04:37,870
your animations are slow, it's
gonna really torpedo

118
00:04:37,870 --> 00:04:40,630
engagement.

119
00:04:40,630 --> 00:04:41,350
How do we fix it?

120
00:04:41,350 --> 00:04:44,690
Well, that previous slide I put
up has some good advice.

121
00:04:44,690 --> 00:04:47,340
Basically, we just use the tools
that exist today to hunt

122
00:04:47,340 --> 00:04:50,345
down these painful repaints, or
unnecessary repaints, and

123
00:04:50,345 --> 00:04:52,290
then fix them.

124
00:04:52,290 --> 00:04:54,930
Again, these things come from
visually complex elements,

125
00:04:54,930 --> 00:04:56,750
but, luckily, the designers
are telling us today

126
00:04:56,750 --> 00:04:58,230
that flat is cool.

127
00:04:58,230 --> 00:05:01,960
So it's very easy to have a
nice site and a fast site.

128
00:05:01,960 --> 00:05:04,150
All you do is just have a
flat, no gradients, no

129
00:05:04,150 --> 00:05:06,540
background images, no, no
nothing, right, just flat

130
00:05:06,540 --> 00:05:09,930
colors, and then you're good
to go on all fronts.

131
00:05:09,930 --> 00:05:12,230
But seriously, what are some
real techniques that we can

132
00:05:12,230 --> 00:05:14,400
talk about today that make
an impact on rendering

133
00:05:14,400 --> 00:05:16,150
performance?

134
00:05:16,150 --> 00:05:18,110
The first is using
requestAnimationFrame instead

135
00:05:18,110 --> 00:05:19,670
of setTimeout.

136
00:05:19,670 --> 00:05:22,450
Historically, if you wanted to
execute something on a often

137
00:05:22,450 --> 00:05:24,830
basis, but not as quickly
as possible, you'd use a

138
00:05:24,830 --> 00:05:27,760
setTimeout in JavaScript to
delay that event a given

139
00:05:27,760 --> 00:05:29,300
number of milliseconds.

140
00:05:29,300 --> 00:05:31,430
And people would do things like
take 1,000 milliseconds

141
00:05:31,430 --> 00:05:34,270
to divide by, et cetera, try
to get 16.6 millisecond

142
00:05:34,270 --> 00:05:35,620
execution times.

143
00:05:35,620 --> 00:05:37,920
But we'd rather have people
use, going forward,

144
00:05:37,920 --> 00:05:39,390
requestAnimationFrame.

145
00:05:39,390 --> 00:05:42,360
This is a native browser API
that can optimize these

146
00:05:42,360 --> 00:05:43,470
rendering events.

147
00:05:43,470 --> 00:05:44,990
It can do things like turn
off the animation

148
00:05:44,990 --> 00:05:46,450
till the tab is hidden.

149
00:05:46,450 --> 00:05:49,060
It can optimize battery usage
on mobile devices.

150
00:05:49,060 --> 00:05:50,690
And since it's a native browser
API, it's just gonna

151
00:05:50,690 --> 00:05:53,000
be more efficient at
doing animations.

152
00:05:53,000 --> 00:05:55,290
Support across browsers is
pretty good, certainly in

153
00:05:55,290 --> 00:05:55,920
modern browsers.

154
00:05:55,920 --> 00:05:58,420
You can shim it for older
versions of IE, but it's well

155
00:05:58,420 --> 00:06:02,630
supported across all modern
versions of browsers.

156
00:06:02,630 --> 00:06:05,120
Another thing to point out is
that consistent frame rate is

157
00:06:05,120 --> 00:06:07,500
better than a high variable
frame rate.

158
00:06:07,500 --> 00:06:09,890
So if you can get your page to
render consistently at 40

159
00:06:09,890 --> 00:06:12,080
frames per second the entire
time, that's better than

160
00:06:12,080 --> 00:06:14,200
having it render at 60
sometimes, but as soon as the

161
00:06:14,200 --> 00:06:17,800
user scrolls or an animation
fires, it drops down to 30 and

162
00:06:17,800 --> 00:06:19,190
bounces back and forth.

163
00:06:19,190 --> 00:06:21,310
That's a terrible experience
for end users, so you wanna

164
00:06:21,310 --> 00:06:22,650
make sure that the page
is rendering in

165
00:06:22,650 --> 00:06:23,900
a consistent fashion.

166
00:06:23,900 --> 00:06:26,220

167
00:06:26,220 --> 00:06:27,740
Another technique is
to paint less.

168
00:06:27,740 --> 00:06:29,180
So we talked about how
having too many

169
00:06:29,180 --> 00:06:30,660
paints can be an issue.

170
00:06:30,660 --> 00:06:32,450
A lot of the time, this comes
down to just batching your

171
00:06:32,450 --> 00:06:34,880
paints together and trying to do
these large updates to the

172
00:06:34,880 --> 00:06:38,100
screen fewer times, so just
one slightly larger paint

173
00:06:38,100 --> 00:06:40,980
that's still within your budget
of 60 milliseconds, but

174
00:06:40,980 --> 00:06:43,870
not having tons of paints that
execute on every scroll event

175
00:06:43,870 --> 00:06:47,280
or every hover event,
et cetera.

176
00:06:47,280 --> 00:06:49,030
You can consider the
translateZ hack.

177
00:06:49,030 --> 00:06:50,690
We have some experts on the
panel here today that can talk

178
00:06:50,690 --> 00:06:51,440
more about that.

179
00:06:51,440 --> 00:06:53,870
But, essentially, when you add
translateZ, zero, to an

180
00:06:53,870 --> 00:06:56,510
element in CSS, it doesn't
actually animate that element,

181
00:06:56,510 --> 00:06:58,890
but it does move it to a
different compositing layer,

182
00:06:58,890 --> 00:07:00,720
which can be very useful for
something that's being painted

183
00:07:00,720 --> 00:07:01,430
very often.

184
00:07:01,430 --> 00:07:02,840
So it'll get put under
the GPU, and the GPU

185
00:07:02,840 --> 00:07:05,510
can optimize that.

186
00:07:05,510 --> 00:07:08,730
Speaking of the GPU, you wanna
make sure you're optimizing

187
00:07:08,730 --> 00:07:11,550
how often you're uploading
textures to the GPU.

188
00:07:11,550 --> 00:07:14,470
The GPU is extremely good at
manipulating textures that

189
00:07:14,470 --> 00:07:18,410
have been shipped to it, but
if you saturate that bus

190
00:07:18,410 --> 00:07:21,390
between the CPU and the GPU by
trying to push textures back

191
00:07:21,390 --> 00:07:23,430
and forth, you're gonna
have problems.

192
00:07:23,430 --> 00:07:26,190
So this really comes down to
understanding when you're

193
00:07:26,190 --> 00:07:28,830
forcing stuff to go to the GPU,
and trying to make sure

194
00:07:28,830 --> 00:07:30,700
you're not doing that too much,
but doing it enough to

195
00:07:30,700 --> 00:07:33,940
leverage it when
it makes sense.

196
00:07:33,940 --> 00:07:35,750
And then, finally, this comes
from a post that was written

197
00:07:35,750 --> 00:07:38,890
by Paul Lewis, one of our
panelists, over here.

198
00:07:38,890 --> 00:07:40,070
Don't guess it, test it.

199
00:07:40,070 --> 00:07:43,560
It's really hard to give you
hard and fast rules for

200
00:07:43,560 --> 00:07:45,860
rendering performance on the web
today, because they're so

201
00:07:45,860 --> 00:07:48,790
specific to the site
characteristics.

202
00:07:48,790 --> 00:07:51,040
It can be a single animation
that's causing your problems.

203
00:07:51,040 --> 00:07:53,450
It can be a single CSS
rule, in some cases.

204
00:07:53,450 --> 00:07:55,960
So it really comes down to using
the tools to find out

205
00:07:55,960 --> 00:07:58,600
where your page is slow.

206
00:07:58,600 --> 00:08:00,790
If you want more resources,
there's a great site put

207
00:08:00,790 --> 00:08:03,100
together by some folks at
Google, jankfree.org.

208
00:08:03,100 --> 00:08:06,860
It aggregates slides, videos,
and articles about this topic,

209
00:08:06,860 --> 00:08:09,290
and there's a lot of excellent
information on there.

210
00:08:09,290 --> 00:08:12,680
And with that, I'm gonna turn
it over to the panel.

211
00:08:12,680 --> 00:08:14,410
ANDRE BEHRENS: Here,
you want to switch?

212
00:08:14,410 --> 00:08:15,660
There, you hold that.

213
00:08:15,660 --> 00:08:22,296

214
00:08:22,296 --> 00:08:25,290
OK.

215
00:08:25,290 --> 00:08:31,160
We're gonna try and get up the
contribution screen here.

216
00:08:31,160 --> 00:08:33,500
Beautiful.

217
00:08:33,500 --> 00:08:35,289
OK, so let's go to our
first question.

218
00:08:35,289 --> 00:08:37,479
Pete Miller.

219
00:08:37,479 --> 00:08:38,928
Could someone get a microphone
to Pete?

220
00:08:38,928 --> 00:08:42,320

221
00:08:42,320 --> 00:08:43,570
PETE MILLER: Question.

222
00:08:43,570 --> 00:08:45,260

223
00:08:45,260 --> 00:08:46,710
So anonymous question here.

224
00:08:46,710 --> 00:08:50,390
If there were a YSlow for
rendering performance, what

225
00:08:50,390 --> 00:08:53,350
would its test be, what changes
would be easiest to

226
00:08:53,350 --> 00:08:57,390
implement, and which would
have the biggest impact?

227
00:08:57,390 --> 00:08:57,726
ANDRE BEHRENS: All right,
someone from

228
00:08:57,726 --> 00:08:58,400
the panel wanna go?

229
00:08:58,400 --> 00:09:01,280
Paul, do you have an
idea for them?

230
00:09:01,280 --> 00:09:04,230
PAUL LIST: I think we covered
this in the introduction talk.

231
00:09:04,230 --> 00:09:08,070
A YSlow for rendering
performance is, I won't go so

232
00:09:08,070 --> 00:09:10,480
far as to say useless, but it's
pretty, it's gonna be

233
00:09:10,480 --> 00:09:13,030
very difficult, because what
are we looking for?

234
00:09:13,030 --> 00:09:14,420
We're looking for
layout problems.

235
00:09:14,420 --> 00:09:16,290
What triggers the
layout problem?

236
00:09:16,290 --> 00:09:17,790
Is it that you clicked
in this button up

237
00:09:17,790 --> 00:09:18,930
here in the top corner?

238
00:09:18,930 --> 00:09:20,940
Is it that you were scrolling,
and we did something

239
00:09:20,940 --> 00:09:23,270
parallaxy, and that caused
the layout problem?

240
00:09:23,270 --> 00:09:25,000
You start to get into very--

241
00:09:25,000 --> 00:09:27,620
it's very specific to your
application where your

242
00:09:27,620 --> 00:09:30,380
problems are going to show up.

243
00:09:30,380 --> 00:09:34,420
So having an automated testing
framework is gonna be tricky.

244
00:09:34,420 --> 00:09:36,620
That's not to say we shouldn't
try it, but it's not always

245
00:09:36,620 --> 00:09:38,740
gonna be the easiest
thing to do.

246
00:09:38,740 --> 00:09:41,370
So it's something that you run
into YSlow where it goes hey,

247
00:09:41,370 --> 00:09:42,840
you did this, and
you did this.

248
00:09:42,840 --> 00:09:46,210
We should look at it, but I'm
not, at this point, sure how

249
00:09:46,210 --> 00:09:49,390
broadly effective it would be.

250
00:09:49,390 --> 00:09:52,600
JONATHAN KLEIN: Yeah,
I think it's really

251
00:09:52,600 --> 00:09:53,830
hard to automate that.

252
00:09:53,830 --> 00:09:58,970
But because YSlow is partly
used as an on-demand tool,

253
00:09:58,970 --> 00:10:00,140
that's kind of what
the DevTools

254
00:10:00,140 --> 00:10:01,320
provide for you today.

255
00:10:01,320 --> 00:10:03,230
If you're using YSlow in the
sense that you just pull up a

256
00:10:03,230 --> 00:10:06,350
page and run it manually through
the Chrome extension,

257
00:10:06,350 --> 00:10:08,540
that's what you can do today
with the existing tooling and

258
00:10:08,540 --> 00:10:10,510
see the running performance
for your given site.

259
00:10:10,510 --> 00:10:12,630
So we sort of have something
similar, it's just very, very

260
00:10:12,630 --> 00:10:15,840
difficult to automate,
as Paul was saying.

261
00:10:15,840 --> 00:10:17,870
ARIYA HIDAYAT: So one thing that
you can do is to apply

262
00:10:17,870 --> 00:10:20,000
specific restrictions
in your project.

263
00:10:20,000 --> 00:10:23,630
For example, Jonathan mentioned
about not using the

264
00:10:23,630 --> 00:10:27,610
requestAnimationFrame, so you
can put some checks in your CI

265
00:10:27,610 --> 00:10:31,440
system to prevent somebody from
accidentally put that use

266
00:10:31,440 --> 00:10:33,270
of setTimeout.

267
00:10:33,270 --> 00:10:37,400
So if there's a new additional
setTimeout code, code appears

268
00:10:37,400 --> 00:10:39,490
on some of the JavaScript files,
that should trigger a

269
00:10:39,490 --> 00:10:42,290
warning because, well,
the project used

270
00:10:42,290 --> 00:10:45,560
requestAnimationFrame by
default, for example.

271
00:10:45,560 --> 00:10:48,880
JOSH PEEK: Yeah, I guess the
YSlow stuff normally runs on

272
00:10:48,880 --> 00:10:51,130
page load, but, obviously, all
these rendering performance

273
00:10:51,130 --> 00:10:52,540
problems are something
that's happening

274
00:10:52,540 --> 00:10:53,900
as your app is running.

275
00:10:53,900 --> 00:10:56,960
So there's not really a way
to profile that initially.

276
00:10:56,960 --> 00:10:58,720
So it's basically what we
already have now, which is the

277
00:10:58,720 --> 00:11:00,830
timeline view of showing
all these problems.

278
00:11:00,830 --> 00:11:02,030
And Chrome does a
pretty good job.

279
00:11:02,030 --> 00:11:05,080
I like the new little warning
icon you get when you trigger

280
00:11:05,080 --> 00:11:06,370
a layout in the timeline.

281
00:11:06,370 --> 00:11:09,510
So that's a pretty good
situation to be in right now.

282
00:11:09,510 --> 00:11:11,690
PAUL LIST: Yeah, and there
are some other things.

283
00:11:11,690 --> 00:11:13,660
There are things like telemetry,
which Adobe had

284
00:11:13,660 --> 00:11:16,050
been using brilliantly
for Topcoat.

285
00:11:16,050 --> 00:11:19,160
So when they're checking code,
telemetry is a Python-based

286
00:11:19,160 --> 00:11:21,940
framework that the Chrome
engineers use.

287
00:11:21,940 --> 00:11:27,200
And it runs a bunch of tests
against pages for things like

288
00:11:27,200 --> 00:11:28,890
smoothness of scrolling.

289
00:11:28,890 --> 00:11:31,370
And that's definitely something
I'm interested in

290
00:11:31,370 --> 00:11:34,380
looking at a little bit more
because there may be things

291
00:11:34,380 --> 00:11:39,960
that we should be looking at
that just give us at least an

292
00:11:39,960 --> 00:11:43,410
insight into how the change we
made in our code affected

293
00:11:43,410 --> 00:11:44,590
rendering performance.

294
00:11:44,590 --> 00:11:46,340
And it may be that there's a
certain amount of scripting

295
00:11:46,340 --> 00:11:48,570
that's required from the
developers to set this up in a

296
00:11:48,570 --> 00:11:50,610
meaningful way for that
particular project.

297
00:11:50,610 --> 00:11:53,080
But that might be something that
we wanna take a look at.

298
00:11:53,080 --> 00:11:55,320
And if you're interested, give
me a shout after this because

299
00:11:55,320 --> 00:11:57,570
I'm actually really interested
to find people who want to try

300
00:11:57,570 --> 00:12:02,060
it, to bust out telemetry
and give it a go.

301
00:12:02,060 --> 00:12:02,840
ELI FIDLER: I think also--

302
00:12:02,840 --> 00:12:06,300
I mean, the question is really
what are the magic bullets.

303
00:12:06,300 --> 00:12:09,020
I do this on my site,
and it gets fast.

304
00:12:09,020 --> 00:12:11,110
And there's enough things
going on in rendering

305
00:12:11,110 --> 00:12:14,420
performance, in most cases, that
there isn't a hard and

306
00:12:14,420 --> 00:12:15,760
fast rule there.

307
00:12:15,760 --> 00:12:18,320
Things are very different
on different platforms.

308
00:12:18,320 --> 00:12:20,770
So in addition to being specific
to your site, it's

309
00:12:20,770 --> 00:12:22,780
specific to the device that
you're running on.

310
00:12:22,780 --> 00:12:24,790
It's specific to the version
of the browser that you're

311
00:12:24,790 --> 00:12:26,400
running on that device.

312
00:12:26,400 --> 00:12:28,590
And so testing is really
the best way.

313
00:12:28,590 --> 00:12:31,690
And testing on as many devices
as possible is the best way,

314
00:12:31,690 --> 00:12:34,170
which is not, I'm sure, what
everybody who builds content

315
00:12:34,170 --> 00:12:35,610
wants to hear.

316
00:12:35,610 --> 00:12:37,370
But, of course, there are some
things that are good and that,

317
00:12:37,370 --> 00:12:40,520
I think, people have started
to do a lot more.

318
00:12:40,520 --> 00:12:43,750
Being declarative is usually
better than being imperative.

319
00:12:43,750 --> 00:12:46,950
So if you're going to do an
animation, use CSS animations

320
00:12:46,950 --> 00:12:48,000
or CSS transitions.

321
00:12:48,000 --> 00:12:51,380
Browsers are getting much better
at optimizing things

322
00:12:51,380 --> 00:12:53,800
that are left up
to the browser.

323
00:12:53,800 --> 00:12:56,050
And, historically, you haven't
been able to do that because

324
00:12:56,050 --> 00:13:00,320
performance hasn't been good,
but now it's a lot better.

325
00:13:00,320 --> 00:13:02,840
ANDRE BEHRENS: Well, thinking
about YSlow is not just the

326
00:13:02,840 --> 00:13:04,950
specific implementation
detail.

327
00:13:04,950 --> 00:13:08,540
When I think about other people
that I work with and

328
00:13:08,540 --> 00:13:15,830
multiple levels, are there any
big obvious thing-- like part

329
00:13:15,830 --> 00:13:18,820
of YSlow's power is
just the marketing

330
00:13:18,820 --> 00:13:20,325
message that it delivered.

331
00:13:20,325 --> 00:13:22,010
We have these things.

332
00:13:22,010 --> 00:13:24,060
Oh, OK, we should definitely
all be gzipping everything.

333
00:13:24,060 --> 00:13:27,615
And it sort of consolidated
things that had been known.

334
00:13:27,615 --> 00:13:30,350
ELI FIDLER: So I think CSS
transitions, as opposed to

335
00:13:30,350 --> 00:13:33,850
JavaScript animations, is an
obvious one that most people

336
00:13:33,850 --> 00:13:35,750
are getting now.

337
00:13:35,750 --> 00:13:39,700
My personal one that I've
noticed a lot is people really

338
00:13:39,700 --> 00:13:41,800
like one pixel offset,
one pixel blurred

339
00:13:41,800 --> 00:13:43,850
drop shadows on text.

340
00:13:43,850 --> 00:13:45,280
That's a really expensive
operation.

341
00:13:45,280 --> 00:13:46,530
Don't do that.

342
00:13:46,530 --> 00:13:49,380

343
00:13:49,380 --> 00:13:50,770
ANDRE BEHRENS: All right, think
we'll move on to our

344
00:13:50,770 --> 00:13:52,390
next question.

345
00:13:52,390 --> 00:13:53,640
Jake Archibald.

346
00:13:53,640 --> 00:14:01,290

347
00:14:01,290 --> 00:14:01,530
AUDIENCE: All right.

348
00:14:01,530 --> 00:14:04,940
So tricks like translateZ,
putting that on an element is

349
00:14:04,940 --> 00:14:08,770
quite often a silver bullet in
terms of performance, but

350
00:14:08,770 --> 00:14:11,200
could that be an anti-pattern
tomorrow, like when we used to

351
00:14:11,200 --> 00:14:14,190
tell people to concatenate
strings using array.join.

352
00:14:14,190 --> 00:14:16,910
We now know that's faster than
just doing string plus string.

353
00:14:16,910 --> 00:14:18,300
Is translateZ gonna
be the same thing?

354
00:14:18,300 --> 00:14:22,820

355
00:14:22,820 --> 00:14:24,300
PAUL LIST: Possibly.

356
00:14:24,300 --> 00:14:30,350
There are three steps, I think,
to most performance

357
00:14:30,350 --> 00:14:32,510
problems, which is, first of
all, there's the don't do it

358
00:14:32,510 --> 00:14:35,720
stage where we just blindly tell
you do not do this thing,

359
00:14:35,720 --> 00:14:37,010
it will be bad.

360
00:14:37,010 --> 00:14:39,280
Then there's the next step where
we go ah, now, we can

361
00:14:39,280 --> 00:14:41,710
make it less bad if you were
to do this thing, which is

362
00:14:41,710 --> 00:14:44,170
where I kind of categorize
the translateZ hack.

363
00:14:44,170 --> 00:14:46,520
It's something we'd rather you
didn't have to do, but

364
00:14:46,520 --> 00:14:49,370
sometimes you've gotta step in
and do it just to kind of hint

365
00:14:49,370 --> 00:14:50,500
things up a little bit.

366
00:14:50,500 --> 00:14:52,360
Then there's the final step,
which is hey, this is not a

367
00:14:52,360 --> 00:14:53,600
problem anymore.

368
00:14:53,600 --> 00:14:55,410
Now, there's the other thing
where you go, oh, actually,

369
00:14:55,410 --> 00:14:58,590
all of a sudden, it's
an anti-pattern.

370
00:14:58,590 --> 00:15:01,860
So the array concat versus
array.join versus string

371
00:15:01,860 --> 00:15:04,800
concat thing is the one that's
often mentioned.

372
00:15:04,800 --> 00:15:07,620
And I think the only thing you
can do there is profile.

373
00:15:07,620 --> 00:15:08,590
Again, we've said it before.

374
00:15:08,590 --> 00:15:10,570
But it's like if you're
profiling and it's part of

375
00:15:10,570 --> 00:15:13,430
your build process, then when
something changes in the

376
00:15:13,430 --> 00:15:15,200
implementation, you're
going to see it.

377
00:15:15,200 --> 00:15:16,190
You're gonna go,
whoa, something

378
00:15:16,190 --> 00:15:17,280
went really slow here.

379
00:15:17,280 --> 00:15:18,170
I wasn't expecting that.

380
00:15:18,170 --> 00:15:18,970
What was it?

381
00:15:18,970 --> 00:15:21,840
And you can figure out what it
is that's actually triggering

382
00:15:21,840 --> 00:15:22,400
your problem.

383
00:15:22,400 --> 00:15:25,470
So, yes, it may be a problem
in the future.

384
00:15:25,470 --> 00:15:28,510
There's no crystal ball gazing,
as far as I can tell,

385
00:15:28,510 --> 00:15:31,420
but profile is the
answer for me.

386
00:15:31,420 --> 00:15:33,070
JONATHAN KLEIN: Yeah, on that
I would say that anytime

387
00:15:33,070 --> 00:15:35,180
you're doing something that's
known to be a hack, like,

388
00:15:35,180 --> 00:15:36,640
that's definitely
a hack, right?

389
00:15:36,640 --> 00:15:38,450
That's probably not gonna be
something that we want to be

390
00:15:38,450 --> 00:15:39,490
doing forever.

391
00:15:39,490 --> 00:15:41,800
So anytime that you feel like
you're adding some code that's

392
00:15:41,800 --> 00:15:44,560
just not standards compliant or
it's, translateZ(0) doesn't

393
00:15:44,560 --> 00:15:46,830
make a lot of sense from a
future proofing point of view,

394
00:15:46,830 --> 00:15:48,820
I think it makes sense to
abstract that stuff away.

395
00:15:48,820 --> 00:15:52,420
Because chances are, it's gonna
change going forward,

396
00:15:52,420 --> 00:15:54,060
because it's not
part of a spec.

397
00:15:54,060 --> 00:15:56,160
It's just a work-around.

398
00:15:56,160 --> 00:15:58,330
PAUL LIST: Yeah, one thing I
really don't like, if I'm just

399
00:15:58,330 --> 00:16:01,060
being me for a second, is the
fact that we don't give you a

400
00:16:01,060 --> 00:16:05,040
way to say that you want
something on its own layer.

401
00:16:05,040 --> 00:16:07,770
I don't have a problem with
a developer saying that.

402
00:16:07,770 --> 00:16:12,320
There's kind of a balancing act
of should the developer

403
00:16:12,320 --> 00:16:15,760
have to worry about layers
versus should the browser just

404
00:16:15,760 --> 00:16:17,950
take care of everything.

405
00:16:17,950 --> 00:16:20,760
And in a perfect world, yeah,
the browser would maybe get

406
00:16:20,760 --> 00:16:21,740
everything right for you.

407
00:16:21,740 --> 00:16:24,340
It'd be able to guess your
intent perfectly.

408
00:16:24,340 --> 00:16:27,910
But if it can't, then surely the
best next step is not to

409
00:16:27,910 --> 00:16:30,610
provide a hack, but to provide
a decent API that says yeah,

410
00:16:30,610 --> 00:16:30,920
you know what?

411
00:16:30,920 --> 00:16:32,430
If you need to call
this, call this.

412
00:16:32,430 --> 00:16:34,400
This is what it'll do.

413
00:16:34,400 --> 00:16:38,390
And if you want to abuse it,
OK then, that's your call,

414
00:16:38,390 --> 00:16:38,985
you're the developer.

415
00:16:38,985 --> 00:16:41,690
And we trust you.

416
00:16:41,690 --> 00:16:42,940
And you're not an idiot.

417
00:16:42,940 --> 00:16:45,500

418
00:16:45,500 --> 00:16:48,200
That's just generally how I feel
about this kind of stuff.

419
00:16:48,200 --> 00:16:49,620
JOSH PEEK: Yeah, it's
definitely a leaky

420
00:16:49,620 --> 00:16:50,810
extraption--

421
00:16:50,810 --> 00:16:51,065
PAUL LIST: Right.

422
00:16:51,065 --> 00:16:51,320
JOSH PEEK: --of course.

423
00:16:51,320 --> 00:16:54,640
So I think if the layer
compositing system is

424
00:16:54,640 --> 00:16:57,010
something that you really need
to be concerned about as a

425
00:16:57,010 --> 00:17:01,290
developer, it should be an
explicit opt-in, not going

426
00:17:01,290 --> 00:17:03,920
into this magic voodoo property
that you read about

427
00:17:03,920 --> 00:17:05,260
on Stack Overflow and
you don't really

428
00:17:05,260 --> 00:17:06,010
understand how it works.

429
00:17:06,010 --> 00:17:10,200
But having an explicit API for
declaring layers is, I think,

430
00:17:10,200 --> 00:17:11,950
a good idea, if that's something
we need to be

431
00:17:11,950 --> 00:17:13,369
concerned about.

432
00:17:13,369 --> 00:17:16,960
ELI FIDLER: So translateZ(0) is,
obviously, a hack to force

433
00:17:16,960 --> 00:17:18,089
compositing.

434
00:17:18,089 --> 00:17:21,770
And I think it's actually a
really good declarative API

435
00:17:21,770 --> 00:17:24,609
if, right after you put that on,
or at some point later in

436
00:17:24,609 --> 00:17:26,960
your page, you're about to
animate the value of

437
00:17:26,960 --> 00:17:29,080
translateZ, or you're about
to animate the value of

438
00:17:29,080 --> 00:17:30,030
translate3d.

439
00:17:30,030 --> 00:17:32,560
Then you are exactly saying this
is something I'm setting

440
00:17:32,560 --> 00:17:33,930
now, because I'm gonna
animate it later.

441
00:17:33,930 --> 00:17:35,920
And that's why it does
what it does.

442
00:17:35,920 --> 00:17:38,760
So that you have your content
promoted into a layer, so that

443
00:17:38,760 --> 00:17:41,540
when you animate it, the
next frame is ready.

444
00:17:41,540 --> 00:17:44,100
And a number of properties
are like that.

445
00:17:44,100 --> 00:17:46,540
Those are the properties right
now that force compositing.

446
00:17:46,540 --> 00:17:48,860
And they're there specifically
so that if you are going to

447
00:17:48,860 --> 00:17:52,310
animate them, you're primed
and ready to go.

448
00:17:52,310 --> 00:17:54,900
And maybe there are more things
that should be like

449
00:17:54,900 --> 00:17:58,130
that, but I'm very hesitant
about saying that we should

450
00:17:58,130 --> 00:18:01,640
introduce a new property that
says promote to layer, because

451
00:18:01,640 --> 00:18:03,770
promote to layer isn't something
that web developers

452
00:18:03,770 --> 00:18:04,910
should care about.

453
00:18:04,910 --> 00:18:08,540
PAUL LIST: If you don't have
that, then you have this thing

454
00:18:08,540 --> 00:18:12,190
where developers can't get
good performing code.

455
00:18:12,190 --> 00:18:13,420
If they can't get a good
performing yet, they don't

456
00:18:13,420 --> 00:18:15,320
have anything other
than a hack.

457
00:18:15,320 --> 00:18:18,510
And so either the browser has to
infer perfectly the intent

458
00:18:18,510 --> 00:18:21,140
of the developer and get it
right, or we have the

459
00:18:21,140 --> 00:18:23,400
alternative, which is give them
a way of saying no, this

460
00:18:23,400 --> 00:18:24,420
is what I really mean.

461
00:18:24,420 --> 00:18:26,320
And they're doing that through
this sort of back door at the

462
00:18:26,320 --> 00:18:28,350
moment, which kind of makes me
feel uncomfortable because it

463
00:18:28,350 --> 00:18:31,600
does give rise to hey,
implementation's changed, now

464
00:18:31,600 --> 00:18:34,490
your expectation needs to
change, which is, I think, a

465
00:18:34,490 --> 00:18:36,320
slightly unfair position
to put a developer in.

466
00:18:36,320 --> 00:18:40,000
But, maybe that's just me.

467
00:18:40,000 --> 00:18:41,550
ANDRE BEHRENS: Yeah, it's kind
of interesting that's what the

468
00:18:41,550 --> 00:18:44,020
distinction is between
translateZ and promote to

469
00:18:44,020 --> 00:18:47,720
layer in terms of actual
developer life experience.

470
00:18:47,720 --> 00:18:49,235
AUDIENCE: Can I jump
in for a sec?

471
00:18:49,235 --> 00:18:49,640
ANDRE BEHRENS: Yeah.

472
00:18:49,640 --> 00:18:53,910
AUDIENCE: I feel like I've seen
developers animating top

473
00:18:53,910 --> 00:18:57,550
or left, setting something
position fixed a lot and then

474
00:18:57,550 --> 00:18:59,770
not realizing that that's
going to have different

475
00:18:59,770 --> 00:19:02,510
performance implications than
animating something with

476
00:19:02,510 --> 00:19:05,460
translate or even
margin-right.

477
00:19:05,460 --> 00:19:11,650
So I feel like if we wanted to
let someone animate top, but

478
00:19:11,650 --> 00:19:14,790
give it the performance of
something in its own

479
00:19:14,790 --> 00:19:21,510
compositing layer, then using
some sort of layer-promoting

480
00:19:21,510 --> 00:19:25,380
API would make sense, in
that case, potentially.

481
00:19:25,380 --> 00:19:27,010
ELI FIDLER: I mean, your
specific example right now

482
00:19:27,010 --> 00:19:29,830
also does force a layer
on most platforms.

483
00:19:29,830 --> 00:19:32,460
If you set something to fixed
positioning and then animate

484
00:19:32,460 --> 00:19:33,710
top, it will.

485
00:19:33,710 --> 00:19:37,190

486
00:19:37,190 --> 00:19:40,270
ARIYA HIDAYAT: Just adding one
more twist to the topic.

487
00:19:40,270 --> 00:19:42,780
We also have to remember that
translateZ, or even

488
00:19:42,780 --> 00:19:45,160
compositing layers just half
the equation, right.

489
00:19:45,160 --> 00:19:49,080
For example, if you do that, but
you try to animate, say,

490
00:19:49,080 --> 00:19:52,370
blur radius or border radius, it
doesn't really help because

491
00:19:52,370 --> 00:19:54,560
there are only a couple of
properties that you can apply

492
00:19:54,560 --> 00:19:59,530
to the GPU texture that can
be executed by the GPU

493
00:19:59,530 --> 00:20:01,870
efficiently.

494
00:20:01,870 --> 00:20:05,810
So, again, explicit, or
implicit, or half explicit,

495
00:20:05,810 --> 00:20:09,520
half implicit, web developers
still need to know that only

496
00:20:09,520 --> 00:20:14,582
certain properties you can
run on the layer itself.

497
00:20:14,582 --> 00:20:15,230
ANDRE BEHRENS: Right.

498
00:20:15,230 --> 00:20:17,500
PAUL LIST: And, generally, I
mean, the way I sort of always

499
00:20:17,500 --> 00:20:21,540
pitch it is you're gonna promote
to isolate to layer,

500
00:20:21,540 --> 00:20:22,770
that's probably gonna
get painted.

501
00:20:22,770 --> 00:20:24,710
Or you just want it-- cause
you're gonna move it,

502
00:20:24,710 --> 00:20:28,550
translate-- oh, sorry-- move
it, scale it, fade it, or

503
00:20:28,550 --> 00:20:29,600
rotate it, I think.

504
00:20:29,600 --> 00:20:30,640
ARIYA HIDAYAT: And filter.

505
00:20:30,640 --> 00:20:31,450
PAUL LIST: Yeah, or filter.

506
00:20:31,450 --> 00:20:34,940
And those, Paul actually helped
me figure-- he came up

507
00:20:34,940 --> 00:20:38,220
with those four, which
is really helpful.

508
00:20:38,220 --> 00:20:42,150
So if you're gonna do one of
those things, or if you're

509
00:20:42,150 --> 00:20:44,960
gonna paint something and it's
gonna affect other elements,

510
00:20:44,960 --> 00:20:46,270
then it's a good time
to isolate it.

511
00:20:46,270 --> 00:20:48,220
Other than that, it's, like you
said, it's probably not

512
00:20:48,220 --> 00:20:50,660
gonna offer you anything, and
you're potentially creating

513
00:20:50,660 --> 00:20:52,280
more of a problem because you're
gonna have upload a

514
00:20:52,280 --> 00:20:54,080
texture for that layer
to the GPU.

515
00:20:54,080 --> 00:20:57,690
And if you're on a constrained
device, like a mobile one,

516
00:20:57,690 --> 00:21:00,310
well, you're gonna pay
that tax every time

517
00:21:00,310 --> 00:21:03,340
you change that layer.

518
00:21:03,340 --> 00:21:04,300
JONATHAN KLEIN: One of the
interesting things, I think,

519
00:21:04,300 --> 00:21:06,880
about the web that's happening
right now is we have sort of

520
00:21:06,880 --> 00:21:09,100
two, or not even two,
but whatever, a

521
00:21:09,100 --> 00:21:11,130
gradient of use cases.

522
00:21:11,130 --> 00:21:13,050
Because the browser is now
becoming this platform where

523
00:21:13,050 --> 00:21:15,930
you can do complex animations,
you can do full gaming

524
00:21:15,930 --> 00:21:18,110
experiences, et cetera, but you
can also build a pretty

525
00:21:18,110 --> 00:21:19,510
static website.

526
00:21:19,510 --> 00:21:21,550
So when you talk about
developers shouldn't have to

527
00:21:21,550 --> 00:21:23,340
worry about this, well, if
you're building a high

528
00:21:23,340 --> 00:21:24,990
performance game in the browser,
you probably should

529
00:21:24,990 --> 00:21:26,210
have to worry about
that, right?

530
00:21:26,210 --> 00:21:28,880
But if you're building your
blog, you shouldn't.

531
00:21:28,880 --> 00:21:32,440
So I think there needs to be a
facility for both camps of

532
00:21:32,440 --> 00:21:35,240
people to be able to use these
tools effectively without

533
00:21:35,240 --> 00:21:36,980
having to worry too much if
you're on the low end.

534
00:21:36,980 --> 00:21:39,060
But you should be able to access
those APIs if you're

535
00:21:39,060 --> 00:21:41,230
working on something
really complex.

536
00:21:41,230 --> 00:21:43,650
ANDRE BEHRENS: I think we'll
move on to our next question.

537
00:21:43,650 --> 00:21:46,340
Ben Holland.

538
00:21:46,340 --> 00:21:47,590
Grab the mic.

539
00:21:47,590 --> 00:21:50,490

540
00:21:50,490 --> 00:21:51,490
AUDIENCE: Hey.

541
00:21:51,490 --> 00:21:54,080
So we have reasonably good
tools and insight into

542
00:21:54,080 --> 00:21:57,800
rendering performance in a
dev environment but not

543
00:21:57,800 --> 00:21:59,300
data from the field.

544
00:21:59,300 --> 00:22:01,720
What events or metrics would we
ideally like to be able to

545
00:22:01,720 --> 00:22:04,400
measure and report on
for real users?

546
00:22:04,400 --> 00:22:08,380

547
00:22:08,380 --> 00:22:11,890
JOSH PEEK: The only thing we can
do live in production is

548
00:22:11,890 --> 00:22:14,440
measure the window
performance APIs.

549
00:22:14,440 --> 00:22:16,040
Those are pretty great,
but those only

550
00:22:16,040 --> 00:22:17,270
effect the initial load.

551
00:22:17,270 --> 00:22:19,650
You don't get anything
after the fact.

552
00:22:19,650 --> 00:22:23,310
So being able to tap into the
timeline from JavaScript and

553
00:22:23,310 --> 00:22:25,560
get those actual values
would be great.

554
00:22:25,560 --> 00:22:30,700
I mean, we do some stuff where
we profile method times and

555
00:22:30,700 --> 00:22:33,230
then report these back
over AJAX in our

556
00:22:33,230 --> 00:22:35,230
production app, so.

557
00:22:35,230 --> 00:22:39,180
But you can't get access to any
timeline data live from

558
00:22:39,180 --> 00:22:41,070
JavaScript, so having those
would be great.

559
00:22:41,070 --> 00:22:43,780

560
00:22:43,780 --> 00:22:45,585
JONATHAN KLEIN: Yeah, I'd love
to have real user data in

561
00:22:45,585 --> 00:22:48,360
production as well, but I'd also
love to have even better

562
00:22:48,360 --> 00:22:50,970
synthetic tooling around
it for remote use.

563
00:22:50,970 --> 00:22:53,030
So what I mean by that is to
say right now, there's no

564
00:22:53,030 --> 00:22:55,840
JavaScript API into the frame
rate, for example, that the

565
00:22:55,840 --> 00:22:58,900
Chrome DevTools gives you for
that rendering meter.

566
00:22:58,900 --> 00:23:00,390
So it'd be great if you could
just hook into that with

567
00:23:00,390 --> 00:23:02,460
JavaScript because then you
could write tools that would

568
00:23:02,460 --> 00:23:05,810
basically change different
events, hide nodes while

569
00:23:05,810 --> 00:23:08,860
scrolling the page, and then
read off those frame numbers

570
00:23:08,860 --> 00:23:10,020
and the paint numbers.

571
00:23:10,020 --> 00:23:12,010
And then you could very quickly
narrow down, in an

572
00:23:12,010 --> 00:23:15,370
automated fashion, on the area
that's causing a problem.

573
00:23:15,370 --> 00:23:18,320
So I think that's kind of the
next step is how can we get

574
00:23:18,320 --> 00:23:23,020
code around that paint meter
so we can easily find out

575
00:23:23,020 --> 00:23:23,820
where the problem areas are.

576
00:23:23,820 --> 00:23:24,710
PAUL LIST: I think that's
interesting.

577
00:23:24,710 --> 00:23:27,710
But is that in a lab
environment or

578
00:23:27,710 --> 00:23:28,790
is that in the live?

579
00:23:28,790 --> 00:23:33,060
The reason I ask is because if
you're talking about live--

580
00:23:33,060 --> 00:23:36,310
say, frames per second-- it's
very difficult to separate

581
00:23:36,310 --> 00:23:39,210
signal from noise, because you
don't know if it's contention

582
00:23:39,210 --> 00:23:43,570
at the OS level, if it's a
badly configured monitor,

583
00:23:43,570 --> 00:23:45,940
terrible GPU drivers, contention
at the Chrome

584
00:23:45,940 --> 00:23:48,920
level, or browser level
contention actually within the

585
00:23:48,920 --> 00:23:50,840
page and a bottleneck there.

586
00:23:50,840 --> 00:23:54,480
So just a simple frames per
second probably wouldn't give

587
00:23:54,480 --> 00:23:55,130
you that much.

588
00:23:55,130 --> 00:23:57,480
But in a lab environment, where
you can be pretty sure

589
00:23:57,480 --> 00:23:59,890
that there's nothing else
running and so on, then that

590
00:23:59,890 --> 00:24:01,950
seems to me to be a reasonable
first step.

591
00:24:01,950 --> 00:24:03,540
JONATHAN KLEIN: Yeah, I was
thinking in a lab because

592
00:24:03,540 --> 00:24:06,090
right now, if you wanna take a
page and figure out why its

593
00:24:06,090 --> 00:24:08,490
rendering performance is bad, it
takes a lot of work, right?

594
00:24:08,490 --> 00:24:10,420
So if you could build better
tooling around that in a lab

595
00:24:10,420 --> 00:24:12,260
environment, it could be very
fast to narrow down where the

596
00:24:12,260 --> 00:24:13,130
problem is.

597
00:24:13,130 --> 00:24:13,650
But, yeah, you're right.

598
00:24:13,650 --> 00:24:15,850
It's not gonna work very well
in the real world today.

599
00:24:15,850 --> 00:24:16,960
ANDRE BEHRENS: I think we
have a question from

600
00:24:16,960 --> 00:24:18,210
the room, James Ide.

601
00:24:18,210 --> 00:24:23,494

602
00:24:23,494 --> 00:24:24,490
AUDIENCE: Hi.

603
00:24:24,490 --> 00:24:29,000
So, for some context, I feel
like a lot of the performance

604
00:24:29,000 --> 00:24:30,910
characteristics of how browsers
work, like a lot of

605
00:24:30,910 --> 00:24:33,990
the things in Jonathan's slides,
are understood by a

606
00:24:33,990 --> 00:24:37,610
lot of web developers, and the
DevTools have gone great.

607
00:24:37,610 --> 00:24:39,056
Even I11's really great now.

608
00:24:39,056 --> 00:24:41,150
You should check it out.

609
00:24:41,150 --> 00:24:45,130
But understanding how the
browser works is great if

610
00:24:45,130 --> 00:24:47,710
you're a one-man show
and you're building

611
00:24:47,710 --> 00:24:49,270
your own web page.

612
00:24:49,270 --> 00:24:51,890
And as soon as you start to have
a large team working on

613
00:24:51,890 --> 00:24:54,130
your product, it's very easy
for someone to introduce a

614
00:24:54,130 --> 00:24:55,160
regression.

615
00:24:55,160 --> 00:24:58,890
So I'm wondering, for example,
at Facebook, we have a library

616
00:24:58,890 --> 00:25:02,730
called REACT, which helps avoid
layout thrash when we

617
00:25:02,730 --> 00:25:04,040
render our web pages.

618
00:25:04,040 --> 00:25:07,460
And I'm wondering if there
are, let's say,

619
00:25:07,460 --> 00:25:12,460
organizationally scalable APIs
that the browser vendors can

620
00:25:12,460 --> 00:25:13,320
provide to us.

621
00:25:13,320 --> 00:25:17,180
So, concretely speaking, maybe
asynchronous APIs to decode

622
00:25:17,180 --> 00:25:20,440
images, or asynchronous APIs
to commute, compute the

623
00:25:20,440 --> 00:25:23,020
dimensions of a DOM element,
things that are synchronous

624
00:25:23,020 --> 00:25:25,730
and slow down the
page right now.

625
00:25:25,730 --> 00:25:28,290
Are there these types of things
that the DOM could

626
00:25:28,290 --> 00:25:31,130
provide to us that you think
would be helpful?

627
00:25:31,130 --> 00:25:32,680
ELI FIDLER: So I think that's
actually one of the most

628
00:25:32,680 --> 00:25:37,080
interesting areas of active
development in at least most

629
00:25:37,080 --> 00:25:38,660
of the popular web engines
right now.

630
00:25:38,660 --> 00:25:42,940
Definitely WebKit and Blink
are both working on--

631
00:25:42,940 --> 00:25:44,420
they call it different things--
but some sort of

632
00:25:44,420 --> 00:25:47,310
incremental layout where certain
properties, when you

633
00:25:47,310 --> 00:25:50,110
request them from JavaScript,
don't trigger a full re-layout

634
00:25:50,110 --> 00:25:51,440
of the page.

635
00:25:51,440 --> 00:25:55,990
And I can't give you a list
of what works right now or

636
00:25:55,990 --> 00:25:58,170
anything because a lot of this
is research code right now.

637
00:25:58,170 --> 00:26:02,160
But this is a very good example
of where the browser

638
00:26:02,160 --> 00:26:05,060
can make things fast without
you changing anything.

639
00:26:05,060 --> 00:26:07,470
So right now, there's a couple
of properties that you asked

640
00:26:07,470 --> 00:26:11,630
for, like offsetWidth, that will
trigger a full re-layout

641
00:26:11,630 --> 00:26:14,970
of the entire page and doesn't
technically have to, but,

642
00:26:14,970 --> 00:26:17,140
right now, the way that
the engines work,

643
00:26:17,140 --> 00:26:18,120
that's what they do.

644
00:26:18,120 --> 00:26:20,000
So stay tuned.

645
00:26:20,000 --> 00:26:22,470
But there's a lot of things
there that are getting faster

646
00:26:22,470 --> 00:26:24,910
without web developers having
to change things.

647
00:26:24,910 --> 00:26:30,740
In terms of adding new DOM APIs,
we have standards bodies

648
00:26:30,740 --> 00:26:33,740
and they accept public
comments.

649
00:26:33,740 --> 00:26:37,590
And definitely we've seen a lot
of people providing that

650
00:26:37,590 --> 00:26:39,430
sort of feedback.

651
00:26:39,430 --> 00:26:41,540
ANDRE BEHRENS: We have another
question from Mike Petrovich.

652
00:26:41,540 --> 00:26:46,210

653
00:26:46,210 --> 00:26:47,460
Mic.

654
00:26:47,460 --> 00:26:51,670

655
00:26:51,670 --> 00:26:54,700
AUDIENCE: So to Jonathan's point
about synthetic testing,

656
00:26:54,700 --> 00:26:58,240
I know Etsy does synthetic
testing for initial page speed

657
00:26:58,240 --> 00:26:59,310
performance.

658
00:26:59,310 --> 00:27:01,890
But what if we did something
like that with using Selenium

659
00:27:01,890 --> 00:27:04,330
test in a synthetic environment
that would

660
00:27:04,330 --> 00:27:08,965
actually, in a context-sensitive
area for

661
00:27:08,965 --> 00:27:12,040
your app, kind of how it's meant
to work going, clicking

662
00:27:12,040 --> 00:27:15,420
around, 200 milliseconds later,
clicking this other

663
00:27:15,420 --> 00:27:17,360
element, and that's all
affected by different

664
00:27:17,360 --> 00:27:20,560
rendering speeds, and also
JavaScript evaluations.

665
00:27:20,560 --> 00:27:22,900
So it's a more of a real-world
example than just, straight

666
00:27:22,900 --> 00:27:25,030
up, how long did it take
to render this?

667
00:27:25,030 --> 00:27:28,000
And it doesn't work at a
generalized level like, there

668
00:27:28,000 --> 00:27:32,160
seems to be a consensus, but
on a very contextual basis,

669
00:27:32,160 --> 00:27:34,400
what about using kind of
automated behavioral tools

670
00:27:34,400 --> 00:27:36,390
such as that?

671
00:27:36,390 --> 00:27:36,740
JONATHAN KLEIN: Yes.

672
00:27:36,740 --> 00:27:38,640
We sort of have that today
with webpagetest, right?

673
00:27:38,640 --> 00:27:41,140
So Pat's here, and he built an
awesome tool that allows you

674
00:27:41,140 --> 00:27:44,490
to do multi-page flows, and see
screenshots for every step

675
00:27:44,490 --> 00:27:47,460
of the way, and look at
waterfalls that show

676
00:27:47,460 --> 00:27:49,100
JavaScript execution, and see
how long those things are

677
00:27:49,100 --> 00:27:52,520
taking, and even monitor CPU
during that process.

678
00:27:52,520 --> 00:27:54,920
So that's, I think, the best
proxy we have for it today,

679
00:27:54,920 --> 00:27:57,100
but, again, one of the
challenging things is that we

680
00:27:57,100 --> 00:28:01,250
can't currently get data on
frame rate or paint events out

681
00:28:01,250 --> 00:28:04,350
of the browser through an API,
so that's where you sort of

682
00:28:04,350 --> 00:28:05,230
run into that wall.

683
00:28:05,230 --> 00:28:07,340
So you can get part of the way
there, but you can't-- you

684
00:28:07,340 --> 00:28:10,000
still can't calculate how long
a paint takes, as far as I'm

685
00:28:10,000 --> 00:28:12,290
aware, unless you patch
Chrome, maybe.

686
00:28:12,290 --> 00:28:13,400
I don't know.

687
00:28:13,400 --> 00:28:15,720
PAUL LIST: Telemetry actually
runs Chrome with a very

688
00:28:15,720 --> 00:28:18,390
specific flag,
enable-GPU-benchmarking, which

689
00:28:18,390 --> 00:28:22,120
enables a GPU benchmarking
API.

690
00:28:22,120 --> 00:28:25,100
And that will give you some
stuff, and, in fact, yeah,

691
00:28:25,100 --> 00:28:27,270
that's the reason telemetry
can get the data out.

692
00:28:27,270 --> 00:28:29,890
Then the other thing you can
do is connect to DevTools--

693
00:28:29,890 --> 00:28:31,930
it's over the web socket--

694
00:28:31,930 --> 00:28:35,750
and get it to run, do the thing,
pull off the timeline

695
00:28:35,750 --> 00:28:38,240
data, and then check for paint
records and so forth.

696
00:28:38,240 --> 00:28:39,620
So there are things there.

697
00:28:39,620 --> 00:28:43,280
They are not, I would say, that
easily, sort of like,

698
00:28:43,280 --> 00:28:47,380
sort of grunt-taskable and just
easily inserted into your

699
00:28:47,380 --> 00:28:48,190
workflow today.

700
00:28:48,190 --> 00:28:50,850
And I think that's something I'm
very interested in, is to

701
00:28:50,850 --> 00:28:53,090
whether we can actually make
that a thing that's easy for

702
00:28:53,090 --> 00:28:55,950
developers to just include
in their build steps.

703
00:28:55,950 --> 00:28:57,750
ARIYA HIDAYAT: A good example
of the use of telemetry is

704
00:28:57,750 --> 00:28:59,530
Adobe Topcoat project.

705
00:28:59,530 --> 00:29:02,560
I think they have a fantastic
dashboard that shows how long

706
00:29:02,560 --> 00:29:04,950
does it take to render a
button for every single

707
00:29:04,950 --> 00:29:06,800
revision of the code, the CSS.

708
00:29:06,800 --> 00:29:09,900
So if you accidentally change
the CSS and it slows down the

709
00:29:09,900 --> 00:29:11,930
rendering of button, then you'll
know it immediately.

710
00:29:11,930 --> 00:29:15,778
I think this is all using
Chrome telemetry.

711
00:29:15,778 --> 00:29:16,700
ANDRE BEHRENS: All right.

712
00:29:16,700 --> 00:29:19,211
Next question, Chen It Tsai.

713
00:29:19,211 --> 00:29:20,461
AUDIENCE: Yeah.

714
00:29:20,461 --> 00:29:22,900

715
00:29:22,900 --> 00:29:24,663
ANDRE BEHRENS: Microphone.

716
00:29:24,663 --> 00:29:25,913
AUDIENCE: Down front.

717
00:29:25,913 --> 00:29:30,565

718
00:29:30,565 --> 00:29:33,130
So the question is how can
we track the performance

719
00:29:33,130 --> 00:29:35,820
detriment that third-party
scripts, such as ads, social

720
00:29:35,820 --> 00:29:38,080
buttons, or anything you wanna
add, have on rendering

721
00:29:38,080 --> 00:29:40,493
performance, and, I guess, steps
to kinda mediate that

722
00:29:40,493 --> 00:29:41,743
without being too hacky?

723
00:29:41,743 --> 00:29:45,110

724
00:29:45,110 --> 00:29:46,874
JONATHAN KLEIN: Come back in
two hours or whatever.

725
00:29:46,874 --> 00:29:48,080
[LAUGHTER]

726
00:29:48,080 --> 00:29:49,620
PAUL LIST: I think profile.

727
00:29:49,620 --> 00:29:53,320
I mean, you should know how
your app is running.

728
00:29:53,320 --> 00:29:55,190
And then you should know what
happens when you add that

729
00:29:55,190 --> 00:29:59,610
thing in, and see what
the change is.

730
00:29:59,610 --> 00:30:03,750
If it's hideous, then you
need to make a decision.

731
00:30:03,750 --> 00:30:07,780
I think operating blindly
with your code is a

732
00:30:07,780 --> 00:30:09,400
very dangerous approach.

733
00:30:09,400 --> 00:30:11,590
It's just, for me, it's
fairly simple.

734
00:30:11,590 --> 00:30:12,970
Get used to the tools
that are available.

735
00:30:12,970 --> 00:30:15,620
They are great tools.

736
00:30:15,620 --> 00:30:18,250
And just go-- make sure you
understand how it runs before

737
00:30:18,250 --> 00:30:20,240
and after the third-party script
to know whether it was

738
00:30:20,240 --> 00:30:21,700
worth adding it in.

739
00:30:21,700 --> 00:30:25,570
I mean, anything you add is
going to have a tax, right?

740
00:30:25,570 --> 00:30:27,800
It's just whether you're happy
to pay the tax, right?

741
00:30:27,800 --> 00:30:30,090
That's really the question.

742
00:30:30,090 --> 00:30:32,190
ELI FIDLER: I mean, we've talked
a lot about painting.

743
00:30:32,190 --> 00:30:35,210
We find that a lot of the issues
about badly written

744
00:30:35,210 --> 00:30:38,350
third-party code is not so much
about painting, but about

745
00:30:38,350 --> 00:30:41,980
adding extra event handlers or
doing busy work when other

746
00:30:41,980 --> 00:30:43,300
things could be happening.

747
00:30:43,300 --> 00:30:48,020
And the remote Web Inspector,
Chrome DevTools, or whatever

748
00:30:48,020 --> 00:30:50,500
is available on all the browsers
today, are really

749
00:30:50,500 --> 00:30:53,315
good at showing you had a scroll
event, and somebody had

750
00:30:53,315 --> 00:30:55,970
an on scroll handler, and it ran
for five seconds, and it

751
00:30:55,970 --> 00:30:59,130
came from Facebook.

752
00:30:59,130 --> 00:31:01,320
Facebook doesn't actually have
a scroll handler that takes

753
00:31:01,320 --> 00:31:01,984
five seconds.

754
00:31:01,984 --> 00:31:06,457
[LAUGHTER]

755
00:31:06,457 --> 00:31:08,950
ANDRE BEHRENS: OK.

756
00:31:08,950 --> 00:31:10,790
So let's go on to
the next one.

757
00:31:10,790 --> 00:31:12,040
Ed Soden.

758
00:31:12,040 --> 00:31:19,770

759
00:31:19,770 --> 00:31:19,862
AUDIENCE: OK.

760
00:31:19,862 --> 00:31:22,400
So it was an anonymous
question.

761
00:31:22,400 --> 00:31:24,590
What is the easiest thing
browser vendors could do to

762
00:31:24,590 --> 00:31:26,960
make it easy for developers to
optimize the performance of

763
00:31:26,960 --> 00:31:28,210
their sites?

764
00:31:28,210 --> 00:31:32,950

765
00:31:32,950 --> 00:31:33,950
[LAUGHTER]

766
00:31:33,950 --> 00:31:35,900
JONATHAN KLEIN: No, no one--

767
00:31:35,900 --> 00:31:37,520
JOSH PEEK: It's just the
YSlow question again.

768
00:31:37,520 --> 00:31:41,235
Like, what are these magic
things you can do.

769
00:31:41,235 --> 00:31:43,360
JONATHAN KLEIN: Yeah, I think
more to that point, we talked

770
00:31:43,360 --> 00:31:45,180
about this in the last
session, actually.

771
00:31:45,180 --> 00:31:48,430
Because browsers are now being
put on watches, and glasses,

772
00:31:48,430 --> 00:31:51,870
and really low-end phones, it's
hard to say, well, what

773
00:31:51,870 --> 00:31:54,670
can the browsers do to just make
our jobs easier, because

774
00:31:54,670 --> 00:31:57,070
devices keep getting
lower powered.

775
00:31:57,070 --> 00:32:00,290
So I think we're going to keep
seeing new environments for

776
00:32:00,290 --> 00:32:01,210
browsers to operate in.

777
00:32:01,210 --> 00:32:02,980
And it's hard to say, oh, well,
the browser will just

778
00:32:02,980 --> 00:32:03,370
fix it all.

779
00:32:03,370 --> 00:32:04,770
We don't have to do any work.

780
00:32:04,770 --> 00:32:06,710
PAUL LIST: More tools.

781
00:32:06,710 --> 00:32:08,890
That's the only thing I can
think-- more tools.

782
00:32:08,890 --> 00:32:11,720
But that's gotta be balanced,
cause you don't want, if

783
00:32:11,720 --> 00:32:14,440
you've ever used tracing,
tracing is brilliant, but it's

784
00:32:14,440 --> 00:32:16,920
overwhelming at first when
you hit that thing.

785
00:32:16,920 --> 00:32:20,100
You're like what have you
just done to my eyes?

786
00:32:20,100 --> 00:32:22,080
So it has to be balanced.

787
00:32:22,080 --> 00:32:24,430
But I think if we could, for
example, you can't actually

788
00:32:24,430 --> 00:32:27,030
drill down in Chrome DevTools
today inside paint records.

789
00:32:27,030 --> 00:32:29,150
You know that you spent some
time painting, but you don't

790
00:32:29,150 --> 00:32:30,340
know what was painted.

791
00:32:30,340 --> 00:32:34,759
We recently added details on
image decode and resize, so

792
00:32:34,759 --> 00:32:38,140
that you know which image was
decoded and resized, which is

793
00:32:38,140 --> 00:32:38,810
invaluable.

794
00:32:38,810 --> 00:32:43,910
So we can continue to iterate
and improve the tools so that

795
00:32:43,910 --> 00:32:46,370
you're in no doubt
as to where your

796
00:32:46,370 --> 00:32:48,010
bottlenecks have came from.

797
00:32:48,010 --> 00:32:51,490
But, to make your life
easier, you're the

798
00:32:51,490 --> 00:32:53,440
ones writing the code.

799
00:32:53,440 --> 00:32:55,450
ELI FIDLER: I mean, I make
browsers, so I need you to

800
00:32:55,450 --> 00:32:57,340
answer that question for me.

801
00:32:57,340 --> 00:33:00,730
But one thing that I always ask
when I go to conferences

802
00:33:00,730 --> 00:33:03,460
like this is I talk to web
developers and I say what are

803
00:33:03,460 --> 00:33:06,430
the tools that you need that
would tell you things that you

804
00:33:06,430 --> 00:33:07,800
can actually act on?

805
00:33:07,800 --> 00:33:10,660
So when I ask what do you need,
and people tell me I

806
00:33:10,660 --> 00:33:14,630
want to know what's going
on in the paint record.

807
00:33:14,630 --> 00:33:17,410
And then you say, oh, but that
will be different tomorrow, or

808
00:33:17,410 --> 00:33:20,040
that will be different on
different device, by an order

809
00:33:20,040 --> 00:33:23,450
of magnitude, which it often is,
that becomes information

810
00:33:23,450 --> 00:33:25,320
that's very difficult
for them to act on.

811
00:33:25,320 --> 00:33:27,520
So there are some developers who
deliberately target every

812
00:33:27,520 --> 00:33:29,720
single device out there with
individualized code, but those

813
00:33:29,720 --> 00:33:32,330
developers are very rare when
you have the kind of money and

814
00:33:32,330 --> 00:33:33,830
time to spend on that.

815
00:33:33,830 --> 00:33:37,520
So , tell us what you need to
know, and we will try to make

816
00:33:37,520 --> 00:33:38,020
that happen.

817
00:33:38,020 --> 00:33:40,180
Also, we try to just make
everything fast.

818
00:33:40,180 --> 00:33:42,690
ARIYA HIDAYAT: So I have this
gut feeling that, in the near

819
00:33:42,690 --> 00:33:45,455
future, the rendering
performance tool, especially

820
00:33:45,455 --> 00:33:48,640
with painting, will fall
into two categories.

821
00:33:48,640 --> 00:33:53,180
One is how to improve from 10
frame per second to 30, and

822
00:33:53,180 --> 00:33:57,655
the other one is how to go from
40 to 60, or 58 to 60

823
00:33:57,655 --> 00:33:58,880
frame per seconds.

824
00:33:58,880 --> 00:34:01,950
Because what you're looking for
is that quick fix, so that

825
00:34:01,950 --> 00:34:06,080
instead of 10, you run at
30 frame per seconds.

826
00:34:06,080 --> 00:34:06,940
ANDRE BEHRENS: I think
we have a question.

827
00:34:06,940 --> 00:34:11,000
AUDIENCE: So just to say one
thing that you can do is tell

828
00:34:11,000 --> 00:34:11,880
us there is a problem.

829
00:34:11,880 --> 00:34:14,340
So I think, granted, we don't
have best practices exactly at

830
00:34:14,340 --> 00:34:17,300
how to solve it, but given--

831
00:34:17,300 --> 00:34:18,730
I get the point about
doing synthetic

832
00:34:18,730 --> 00:34:20,469
testing, but you also--

833
00:34:20,469 --> 00:34:24,980
most people in the panel agreed
that the profile of how

834
00:34:24,980 --> 00:34:27,230
many frames per second you
get varies per device.

835
00:34:27,230 --> 00:34:30,210
And, of course, you can't
simulate all these different

836
00:34:30,210 --> 00:34:30,870
situations.

837
00:34:30,870 --> 00:34:34,500
If we had some sort of real-user
monitoring at least

838
00:34:34,500 --> 00:34:38,500
telling us, hey, there is a
problem on whatever Android

839
00:34:38,500 --> 00:34:43,630
device X on this page frequently
enough, then that

840
00:34:43,630 --> 00:34:47,020
would motivate me to go buy that
device and run some more

841
00:34:47,020 --> 00:34:50,690
tests, just to sort of balance
the different effects, even

842
00:34:50,690 --> 00:34:54,190
ahead of having the best
practices, for exactly how

843
00:34:54,190 --> 00:34:56,909
would I fix my codes
to make it go away.

844
00:34:56,909 --> 00:34:57,750
JONATHAN KLEIN: Yeah, I think
that's a great point.

845
00:34:57,750 --> 00:35:02,020
And something that that brings
to mind is that with the YSlow

846
00:35:02,020 --> 00:35:03,805
tool release and the web
performance movement that's

847
00:35:03,805 --> 00:35:05,660
been going on for the past 10
years, we've had a lot of

848
00:35:05,660 --> 00:35:07,950
studies that come out saying
look at the top 1,000 Alexa

849
00:35:07,950 --> 00:35:09,960
sites and how bad they are
in these best practices.

850
00:35:09,960 --> 00:35:12,020
That hasn't happened yet,
I think, with rendering

851
00:35:12,020 --> 00:35:12,820
performance.

852
00:35:12,820 --> 00:35:14,550
So I think it'd be useful
just to see--

853
00:35:14,550 --> 00:35:16,700
have somebody go out and look at
popular sites and be like,

854
00:35:16,700 --> 00:35:18,900
look, there are problems here
on these devices, on these

855
00:35:18,900 --> 00:35:22,100
browsers, and just sort of
expose it on a wider basis, so

856
00:35:22,100 --> 00:35:22,860
people are aware
of the problem.

857
00:35:22,860 --> 00:35:25,490
Because I think in this
community, it's obviously

858
00:35:25,490 --> 00:35:25,900
well-known.

859
00:35:25,900 --> 00:35:27,390
But I think in the wider
community, people don't think

860
00:35:27,390 --> 00:35:30,030
as much about rendering
performance.

861
00:35:30,030 --> 00:35:32,550
ARIYA HIDAYAT: Does anyone know
if Google reduces page

862
00:35:32,550 --> 00:35:36,020
rank for sites that are slow?

863
00:35:36,020 --> 00:35:39,880
[LAUGHTER]

864
00:35:39,880 --> 00:35:40,770
PAUL LIST: I'm not saying.

865
00:35:40,770 --> 00:35:41,860
[LAUGHTER]

866
00:35:41,860 --> 00:35:42,500
PAUL LIST: No idea.

867
00:35:42,500 --> 00:35:43,740
ARIYA HIDAYAT: I'm
just asking.

868
00:35:43,740 --> 00:35:44,990
PAUL LIST: I have no idea.

869
00:35:44,990 --> 00:35:49,190

870
00:35:49,190 --> 00:35:49,580
ANDRE BEHRENS: All right.

871
00:35:49,580 --> 00:35:52,590
Our next question comes
from Dunston Caston.

872
00:35:52,590 --> 00:35:58,390

873
00:35:58,390 --> 00:35:58,870
AUDIENCE: Hey.

874
00:35:58,870 --> 00:36:01,980
So my experience with paint
performance usually drops

875
00:36:01,980 --> 00:36:04,270
frames with garbage collection
events and memory management.

876
00:36:04,270 --> 00:36:07,380
What responsibility should web
developers take on for those

877
00:36:07,380 --> 00:36:09,385
two things, memory management
and garbage collection?

878
00:36:09,385 --> 00:36:13,770

879
00:36:13,770 --> 00:36:17,690
PAUL LIST: OK, so the immediate
thing is that GC

880
00:36:17,690 --> 00:36:21,100
causes jank because GC is almost
guaranteed to push you

881
00:36:21,100 --> 00:36:24,500
over that frame budget
of 16 milliseconds.

882
00:36:24,500 --> 00:36:27,400
Your only option is to
try and avoid GC.

883
00:36:27,400 --> 00:36:31,220
This, I think, depends on how
big a problem this is for you,

884
00:36:31,220 --> 00:36:34,300
how much memory churn you
actually have, how much time

885
00:36:34,300 --> 00:36:37,130
garbage collection is actually
taking, and how often it runs,

886
00:36:37,130 --> 00:36:38,600
which is gonna be very
specific to your own

887
00:36:38,600 --> 00:36:39,370
application.

888
00:36:39,370 --> 00:36:40,620
There are things--

889
00:36:40,620 --> 00:36:42,850

890
00:36:42,850 --> 00:36:45,250
we have, on HTML5rocks, we have
an article about using

891
00:36:45,250 --> 00:36:48,850
static memory pools to recycle
objects and so forth.

892
00:36:48,850 --> 00:36:52,810
You're avoiding object creation,
which tends to be

893
00:36:52,810 --> 00:36:55,520
good for the GC.

894
00:36:55,520 --> 00:37:00,450
But, personally speaking,
I don't believe it's--

895
00:37:00,450 --> 00:37:03,630
People have requested can we
have a garbage collection API?

896
00:37:03,630 --> 00:37:07,610
And I would be concerned about
a browser including that

897
00:37:07,610 --> 00:37:11,650
because that one could get
really hairy very quickly.

898
00:37:11,650 --> 00:37:14,305

899
00:37:14,305 --> 00:37:17,640
ANDRE BEHRENS: What would
be the problems?

900
00:37:17,640 --> 00:37:22,380
PAUL LIST: The browser is
uniquely positioned to--

901
00:37:22,380 --> 00:37:23,610
your page is not the
only thing that's

902
00:37:23,610 --> 00:37:24,600
running in the browser--

903
00:37:24,600 --> 00:37:26,880
so it's in a unique position
to know when

904
00:37:26,880 --> 00:37:28,470
garbage should be collected.

905
00:37:28,470 --> 00:37:32,480
And if you were to force the
issue, you may, basically,

906
00:37:32,480 --> 00:37:34,810
make the wrong call.

907
00:37:34,810 --> 00:37:38,830
This is one of these times
where, as they say, the

908
00:37:38,830 --> 00:37:40,970
browser is the one that has all
the information and knows

909
00:37:40,970 --> 00:37:43,110
when it's the right time
to pick up garbage.

910
00:37:43,110 --> 00:37:46,180
Ideally, you want it to do it
at the best point for every

911
00:37:46,180 --> 00:37:49,100
application that's running,
but that's the nature of--

912
00:37:49,100 --> 00:37:51,980
ARIYA HIDAYAT: But what if the
GC API is just a strong hint

913
00:37:51,980 --> 00:37:55,760
for the browser to do garbage
control when it's possible?

914
00:37:55,760 --> 00:37:59,040
PAUL LIST: So if you do that,
then what happens if it

915
00:37:59,040 --> 00:38:01,960
ignores you?

916
00:38:01,960 --> 00:38:03,700
Or if you get different browsers
ignoring you at

917
00:38:03,700 --> 00:38:04,620
different times?

918
00:38:04,620 --> 00:38:06,730
Is it any better than
the browser just

919
00:38:06,730 --> 00:38:08,480
making the call itself?

920
00:38:08,480 --> 00:38:10,350
ARIYA HIDAYAT: But that's the
same situation like the

921
00:38:10,350 --> 00:38:11,850
translateZ layer hacks, right?

922
00:38:11,850 --> 00:38:12,820
PAUL LIST: Yeah.

923
00:38:12,820 --> 00:38:13,540
No, exactly.

924
00:38:13,540 --> 00:38:16,690
And so some of this stuff is
just real world, yeah, we're

925
00:38:16,690 --> 00:38:18,040
just having to do
this right now.

926
00:38:18,040 --> 00:38:21,010
We wish we didn't because
we just want to get

927
00:38:21,010 --> 00:38:24,120
stuff that runs well.

928
00:38:24,120 --> 00:38:25,720
ELI FIDLER: I mean, we've gotten
complaints, mostly from

929
00:38:25,720 --> 00:38:29,770
sites that do permanent
animation all the time that

930
00:38:29,770 --> 00:38:32,660
GCs are a problem, and that's
things like games.

931
00:38:32,660 --> 00:38:37,100
And if you're writing something
that is truly

932
00:38:37,100 --> 00:38:41,100
interrupted by GCs on a regular
basis, then you just

933
00:38:41,100 --> 00:38:42,540
have to create less garbage.

934
00:38:42,540 --> 00:38:46,220
But building a game that's
gonna run at 60 FPS while

935
00:38:46,220 --> 00:38:48,780
doing complicated things is a
hard problem, no matter what

936
00:38:48,780 --> 00:38:50,940
environment it's running in,
and no matter what language

937
00:38:50,940 --> 00:38:52,030
you're running it in.

938
00:38:52,030 --> 00:38:56,050
So I mean, you can't expect that
the browser is just gonna

939
00:38:56,050 --> 00:38:56,910
do it for you.

940
00:38:56,910 --> 00:38:59,370
And I don't think that you could
make an easy decision.

941
00:38:59,370 --> 00:39:02,360
Even if you had a guaranteed
API that said GC now, you

942
00:39:02,360 --> 00:39:04,612
couldn't make an easy decision
about when to call that API.

943
00:39:04,612 --> 00:39:07,990

944
00:39:07,990 --> 00:39:09,000
ANDRE BEHRENS: Well,
what would--

945
00:39:09,000 --> 00:39:10,260
I'm curious.

946
00:39:10,260 --> 00:39:12,440
We hear again and again, and
when we talk about rendering

947
00:39:12,440 --> 00:39:14,573
performance, we have to test,
we have to look, you have to

948
00:39:14,573 --> 00:39:16,310
look at a specific thing.

949
00:39:16,310 --> 00:39:19,340
What is the brightest sign of
hope for the next thing that's

950
00:39:19,340 --> 00:39:21,640
gonna be easier to handle.

951
00:39:21,640 --> 00:39:25,540
I'm curious, if anyone
has a perspective.

952
00:39:25,540 --> 00:39:28,050
PAUL LIST: When you say
easier to handle.

953
00:39:28,050 --> 00:39:28,370
ANDRE BEHRENS: I don't know.

954
00:39:28,370 --> 00:39:32,770
Like certain things, in the
sense of the timeline view,

955
00:39:32,770 --> 00:39:34,750
maybe at least getting a handle
on it, easier than it

956
00:39:34,750 --> 00:39:37,650
was, like you could
actually see it.

957
00:39:37,650 --> 00:39:41,590
I know the inability to
see pictures in the--

958
00:39:41,590 --> 00:39:43,685
Like able to see picture decodes
and say, oh, that was

959
00:39:43,685 --> 00:39:44,280
a picture decode.

960
00:39:44,280 --> 00:39:45,660
That's what that thing was.

961
00:39:45,660 --> 00:39:47,760
Having that show up in
the tools is a easier

962
00:39:47,760 --> 00:39:49,250
thing to deal with.

963
00:39:49,250 --> 00:39:51,360
Is there anything that either
is going to go away or is

964
00:39:51,360 --> 00:39:54,320
gonna be much easier
to test for?

965
00:39:54,320 --> 00:39:56,550
PAUL LIST: In terms of going
away from a Chrome

966
00:39:56,550 --> 00:39:59,020
perspective, there is--

967
00:39:59,020 --> 00:40:00,870
image decodes and resizes
are, at the

968
00:40:00,870 --> 00:40:03,430
moment, extremely expensive.

969
00:40:03,430 --> 00:40:07,180
And as we all probably
know, 60% of the

970
00:40:07,180 --> 00:40:09,200
average page is images.

971
00:40:09,200 --> 00:40:13,320
So if you can fix image decoding
and resizing as a

972
00:40:13,320 --> 00:40:17,710
bottleneck, that helps
enormously with that problem.

973
00:40:17,710 --> 00:40:21,010
So our engineers are definitely
looking at ways to

974
00:40:21,010 --> 00:40:22,130
make that a thing.

975
00:40:22,130 --> 00:40:25,490
The other problem that you often
see is the main thread,

976
00:40:25,490 --> 00:40:27,780
the contention on the main
thread being so high, such

977
00:40:27,780 --> 00:40:32,800
that work can't continue, and
the app becomes unresponsive.

978
00:40:32,800 --> 00:40:35,540
We are looking at ways
of basically

979
00:40:35,540 --> 00:40:37,100
reducing the workload.

980
00:40:37,100 --> 00:40:39,190
That doesn't always necessarily
mean firing off

981
00:40:39,190 --> 00:40:43,140
more threads, which I think is
the sometimes muted idea.

982
00:40:43,140 --> 00:40:46,500

983
00:40:46,500 --> 00:40:50,380
In Chrome's case, we have a
fairly thread-heavy app, so

984
00:40:50,380 --> 00:40:52,650
just creating more threads
wouldn't necessarily solve it.

985
00:40:52,650 --> 00:40:55,020
So what you actually wanna
do is do the work

986
00:40:55,020 --> 00:40:57,130
in a smarter way.

987
00:40:57,130 --> 00:40:59,540
So for example, putting more
work that is suitable for the

988
00:40:59,540 --> 00:41:02,950
GPU to go to the GPU,
that kind of stuff.

989
00:41:02,950 --> 00:41:05,310
From a developer's point of
view, none of that actually

990
00:41:05,310 --> 00:41:09,170
requires action, other than try
and reduce the work that

991
00:41:09,170 --> 00:41:10,470
you're doing, which has
always been the case.

992
00:41:10,470 --> 00:41:14,100
If you're layout bound,
try and reduce layout.

993
00:41:14,100 --> 00:41:17,020
Even if layout gets faster in
the browser, you still want to

994
00:41:17,020 --> 00:41:17,750
do less of it.

995
00:41:17,750 --> 00:41:20,220
The performance is the
art of doing the

996
00:41:20,220 --> 00:41:21,470
least amount of work.

997
00:41:21,470 --> 00:41:24,475

998
00:41:24,475 --> 00:41:25,260
ANDRE BEHRENS: I think
we have a question

999
00:41:25,260 --> 00:41:27,700
from the crowd, Serosh.

1000
00:41:27,700 --> 00:41:28,350
Yes.

1001
00:41:28,350 --> 00:41:29,600
Microphone.

1002
00:41:29,600 --> 00:41:32,080

1003
00:41:32,080 --> 00:41:32,790
AUDIENCE: Hi.

1004
00:41:32,790 --> 00:41:34,550
I have a very simple question.

1005
00:41:34,550 --> 00:41:38,220
So a few weeks ago, I was
developing this web

1006
00:41:38,220 --> 00:41:39,380
application.

1007
00:41:39,380 --> 00:41:43,360
I don't have any complicated
CSS going on, no timeouts,

1008
00:41:43,360 --> 00:41:44,790
very simple layout.

1009
00:41:44,790 --> 00:41:47,490
But it just uses
lot of images.

1010
00:41:47,490 --> 00:41:49,820
So it picks you out images
from Picasa, and

1011
00:41:49,820 --> 00:41:51,520
it shows it to you.

1012
00:41:51,520 --> 00:41:54,400
And it's just slow, especially
the first time.

1013
00:41:54,400 --> 00:41:57,160
The rendering performance
is really bad.

1014
00:41:57,160 --> 00:42:00,500
So what, as a developer, I
can do to increase that

1015
00:42:00,500 --> 00:42:01,750
performance?

1016
00:42:01,750 --> 00:42:03,590

1017
00:42:03,590 --> 00:42:04,780
PAUL LIST: That's a really--

1018
00:42:04,780 --> 00:42:07,020
that is a tough one right
now, if I'm honest.

1019
00:42:07,020 --> 00:42:10,500
From my point of view,
we don't have--

1020
00:42:10,500 --> 00:42:13,120
so when the page is rasterizing,
it does the image

1021
00:42:13,120 --> 00:42:16,000
decodes and resizes in line
as a sort of dependency.

1022
00:42:16,000 --> 00:42:18,335
It gets this drawbit mapline
where it goes OK, and now I

1023
00:42:18,335 --> 00:42:21,340
need to draw an image, and I
need to decode that image, and

1024
00:42:21,340 --> 00:42:22,600
resize it, if necessary.

1025
00:42:22,600 --> 00:42:24,140
And then I can actually
put it in,

1026
00:42:24,140 --> 00:42:25,480
rasterize it into the page.

1027
00:42:25,480 --> 00:42:27,130
And that all happens in line.

1028
00:42:27,130 --> 00:42:31,980
If it was decoupled from the
rasterization, and there was a

1029
00:42:31,980 --> 00:42:34,280
gap where it was and then
it appeared later, that

1030
00:42:34,280 --> 00:42:34,870
might be one thing.

1031
00:42:34,870 --> 00:42:37,880
But as a developer, there's not
a lot you can do, apart

1032
00:42:37,880 --> 00:42:41,130
from, perhaps, batch in your
images is something you could

1033
00:42:41,130 --> 00:42:42,010
potentially look at.

1034
00:42:42,010 --> 00:42:44,580
Because it's all
done on demand.

1035
00:42:44,580 --> 00:42:46,040
Again, this is from a
Chrome prospective.

1036
00:42:46,040 --> 00:42:47,970
It looks at what it needs
to rasterize.

1037
00:42:47,970 --> 00:42:51,020
If that's 30 images, 30 images
are gonna get queued up for

1038
00:42:51,020 --> 00:42:52,940
decoding and resizing
in one go .

1039
00:42:52,940 --> 00:42:54,640
It might be--

1040
00:42:54,640 --> 00:42:57,780
it depends on the app-- but it
might be better to hold off

1041
00:42:57,780 --> 00:43:01,910
and go, can I do these one by
one or just over a few frames,

1042
00:43:01,910 --> 00:43:04,650
so that I'm not hitting
everything at once.

1043
00:43:04,650 --> 00:43:09,040
That's sometimes maybe a thing,
but I offer that advice

1044
00:43:09,040 --> 00:43:10,620
without knowing the
application in

1045
00:43:10,620 --> 00:43:15,540
detail, so use it wisely.

1046
00:43:15,540 --> 00:43:17,500
ARIYA HIDAYAT: Does it need
to show all those

1047
00:43:17,500 --> 00:43:20,065
30 images at once?

1048
00:43:20,065 --> 00:43:21,520
AUDIENCE: So no, not really.

1049
00:43:21,520 --> 00:43:24,280
And that was one of the
things I tried--

1050
00:43:24,280 --> 00:43:24,820
Not really.

1051
00:43:24,820 --> 00:43:28,820
And that was one of the things I
tried to do, so to just show

1052
00:43:28,820 --> 00:43:33,160
the images, whatever is visible
in one page size.

1053
00:43:33,160 --> 00:43:36,580
But even then, first time, you
are getting, let's say, 10

1054
00:43:36,580 --> 00:43:40,130
images, it's visibly slow.

1055
00:43:40,130 --> 00:43:43,725
And I've seen similar pattern
in other website, too, like

1056
00:43:43,725 --> 00:43:46,890
the well-known websites, so
I wasn't sure if there's

1057
00:43:46,890 --> 00:43:49,750
anything can be done about it.

1058
00:43:49,750 --> 00:43:53,070
PAUL LIST: And we are trying
to reduce the tax that is

1059
00:43:53,070 --> 00:43:56,380
levied for decodes
and resizes.

1060
00:43:56,380 --> 00:43:57,540
ELI FIDLER: I mean, we just
had a whole panel talking

1061
00:43:57,540 --> 00:43:58,800
about images.

1062
00:43:58,800 --> 00:44:00,350
Images are expensive.

1063
00:44:00,350 --> 00:44:03,150
Having to touch every pixel in
an image and doing decodes and

1064
00:44:03,150 --> 00:44:04,910
things like that is an
expensive operation.

1065
00:44:04,910 --> 00:44:07,600
There's fundamentally no way
around the fact we have to do

1066
00:44:07,600 --> 00:44:10,070
a lot of work when
we show images.

1067
00:44:10,070 --> 00:44:12,000
But the techniques that were
talked about in the last

1068
00:44:12,000 --> 00:44:13,840
panel, especially if you control
your images-- in your

1069
00:44:13,840 --> 00:44:14,940
case you may not--

1070
00:44:14,940 --> 00:44:19,100
but putting low quality images
in as placeholders, and then

1071
00:44:19,100 --> 00:44:21,510
asynchronously bringing in
higher quality versions.

1072
00:44:21,510 --> 00:44:25,300
Or carefully choosing what types
of images that you're

1073
00:44:25,300 --> 00:44:28,260
using, what compression formats,
that sort of thing,

1074
00:44:28,260 --> 00:44:31,740
for whatever's fast for your
specific operation, is

1075
00:44:31,740 --> 00:44:34,500
something that you can do to
optimize image-heavy sites.

1076
00:44:34,500 --> 00:44:36,040
But fundamentally, images
are expensive.

1077
00:44:36,040 --> 00:44:36,910
There's no way around that.

1078
00:44:36,910 --> 00:44:39,200
PAUL LIST: It's interesting, as
a side note, that when the

1079
00:44:39,200 --> 00:44:43,350
last panel was talking, there
was obviously a lot of

1080
00:44:43,350 --> 00:44:44,940
discussion about bandwidth.

1081
00:44:44,940 --> 00:44:47,090
And that's only part of the
picture when you're talking

1082
00:44:47,090 --> 00:44:47,770
about images, right.

1083
00:44:47,770 --> 00:44:50,010
Which is the other side of this
is how long, then, does

1084
00:44:50,010 --> 00:44:52,330
it take me to decode
it and resize it?

1085
00:44:52,330 --> 00:44:54,000
So you actually need a
full understanding.

1086
00:44:54,000 --> 00:44:59,010
You could save time on the
transfer of an image, yay, and

1087
00:44:59,010 --> 00:45:01,370
then have something that is
actually really horrible to

1088
00:45:01,370 --> 00:45:05,310
decode or is horrible to resize
on the other side.

1089
00:45:05,310 --> 00:45:09,010
So your overall picture is
actually either worse, or the

1090
00:45:09,010 --> 00:45:12,410
same, or better, but you need
to understand the whole life

1091
00:45:12,410 --> 00:45:15,400
cycle of an image to actually
know whether or not you're

1092
00:45:15,400 --> 00:45:16,990
doing the right thing.

1093
00:45:16,990 --> 00:45:20,200
And also the low quality
placeholder, switch that with

1094
00:45:20,200 --> 00:45:21,800
a high res one.

1095
00:45:21,800 --> 00:45:23,750
Could be really good, but then
you're also trading off the

1096
00:45:23,750 --> 00:45:25,820
fact that you probably have a
second request to get your

1097
00:45:25,820 --> 00:45:26,920
higher res image.

1098
00:45:26,920 --> 00:45:29,030
So it's not just a
straightforward, often,

1099
00:45:29,030 --> 00:45:31,830
anyway, and it's very specific
to your app and what it is

1100
00:45:31,830 --> 00:45:32,800
that's worthwhile doing.

1101
00:45:32,800 --> 00:45:34,170
ARIYA HIDAYAT: It'll be
interesting to see if, in the

1102
00:45:34,170 --> 00:45:37,740
near future, instead of a single
CPU alone responsible

1103
00:45:37,740 --> 00:45:40,400
for images, we could have
GPAC core processors.

1104
00:45:40,400 --> 00:45:42,740
PAUL LIST: Ooh.

1105
00:45:42,740 --> 00:45:43,180
ANDRE BEHRENS: I
think we have a

1106
00:45:43,180 --> 00:45:44,430
question from Jake Archibald.

1107
00:45:44,430 --> 00:45:49,310

1108
00:45:49,310 --> 00:45:50,990
ELI FIDLER: While he's getting
the mic, image decoding is

1109
00:45:50,990 --> 00:45:54,110
actually hardware accelerated,
in many cases.

1110
00:45:54,110 --> 00:45:57,410
AUDIENCE: So on the scrolling
to load images thing, like

1111
00:45:57,410 --> 00:45:59,640
when they're out of view,
use a scroll event to

1112
00:45:59,640 --> 00:46:00,900
bring the images in.

1113
00:46:00,900 --> 00:46:03,020
I just wanted to point out that
that's a kind of massive

1114
00:46:03,020 --> 00:46:05,940
anti-pattern on a mobile,
because if the radio falls

1115
00:46:05,940 --> 00:46:08,940
asleep, or any device with a
cellular connection, waking

1116
00:46:08,940 --> 00:46:11,190
that radio up comes with
a huge latency and

1117
00:46:11,190 --> 00:46:12,340
will ruin the battery.

1118
00:46:12,340 --> 00:46:14,870
Now, on the resource priority
spec, we've got a new

1119
00:46:14,870 --> 00:46:16,990
attribute called postpone, which
hands that power back to

1120
00:46:16,990 --> 00:46:18,530
the browser and lets
the browser

1121
00:46:18,530 --> 00:46:20,140
sort of render without--

1122
00:46:20,140 --> 00:46:23,040
it can defer the image loading,
downloading, if it's

1123
00:46:23,040 --> 00:46:24,290
out of view.

1124
00:46:24,290 --> 00:46:26,210

1125
00:46:26,210 --> 00:46:29,330
PAUL LIST: I would love, as well
as deferring the image

1126
00:46:29,330 --> 00:46:31,200
downloading, I'd actually
love the ability to

1127
00:46:31,200 --> 00:46:34,030
defer decoding as well.

1128
00:46:34,030 --> 00:46:36,470
I don't see why you'd have
one, not the other.

1129
00:46:36,470 --> 00:46:37,200
Don't load this.

1130
00:46:37,200 --> 00:46:38,570
OK, do load it, fine.

1131
00:46:38,570 --> 00:46:39,550
But don't decode it.

1132
00:46:39,550 --> 00:46:40,060
OK, do decode it.

1133
00:46:40,060 --> 00:46:41,760
It's fine.

1134
00:46:41,760 --> 00:46:43,520
That seems to go hand-in-hand
to me.

1135
00:46:43,520 --> 00:46:47,000
And unless I'm crazy,
it's possible.

1136
00:46:47,000 --> 00:46:49,010
ELI FIDLER: That's exactly the
magic of Web Audio for audio,

1137
00:46:49,010 --> 00:46:51,270
cause decoding the audio is
expensive, so you want to do

1138
00:46:51,270 --> 00:46:52,430
it first, so it's ready.

1139
00:46:52,430 --> 00:46:54,580
Maybe we can do Web
Audio for images.

1140
00:46:54,580 --> 00:46:56,860
Somebody write a spec.

1141
00:46:56,860 --> 00:46:58,110
PAUL LIST: That's
a great idea.

1142
00:46:58,110 --> 00:47:01,190

1143
00:47:01,190 --> 00:47:02,440
ANDRE BEHRENS: Next question.

1144
00:47:02,440 --> 00:47:04,790

1145
00:47:04,790 --> 00:47:06,040
Matt Todd.

1146
00:47:06,040 --> 00:47:18,030

1147
00:47:18,030 --> 00:47:21,820
AUDIENCE: Hey, this is an
anonymous question.

1148
00:47:21,820 --> 00:47:24,370
What have been the biggest wins
and wastes of time at

1149
00:47:24,370 --> 00:47:25,420
real websites?

1150
00:47:25,420 --> 00:47:30,040
And I think balancing that
between front-end developers

1151
00:47:30,040 --> 00:47:33,575
and web developers, but also
from browser implementation

1152
00:47:33,575 --> 00:47:38,660
and development, what have
been really rewarding

1153
00:47:38,660 --> 00:47:41,790
endeavors, and what have been
huge wastes of time that have

1154
00:47:41,790 --> 00:47:44,160
taken more time to actually
produce any kind of benefit

1155
00:47:44,160 --> 00:47:46,210
whatsoever?

1156
00:47:46,210 --> 00:47:50,250
ELI FIDLER: We still see a lot
of sites that, in busy loops,

1157
00:47:50,250 --> 00:47:54,710
add one node to the DOM, and
then ask for a property that

1158
00:47:54,710 --> 00:47:56,750
requires you to do a layout,
and then add a note to the

1159
00:47:56,750 --> 00:47:59,010
DOM, and then ask for a property
that requires a

1160
00:47:59,010 --> 00:48:00,990
layout in a really tight loop.

1161
00:48:00,990 --> 00:48:02,920
And this is a huge
anti-pattern.

1162
00:48:02,920 --> 00:48:04,180
We've been telling people
this forever.

1163
00:48:04,180 --> 00:48:06,950
Most people are pretty good
about batching nodes dumped

1164
00:48:06,950 --> 00:48:09,330
into the DOM and that sort of
thing, but still a ton of

1165
00:48:09,330 --> 00:48:11,010
people do this all the time.

1166
00:48:11,010 --> 00:48:14,330
JOSH PEEK: I feel like that
doesn't happen so much where

1167
00:48:14,330 --> 00:48:16,910
you see the tight loop, but it's
more so that you have all

1168
00:48:16,910 --> 00:48:19,090
these other components on the
page, where one will add

1169
00:48:19,090 --> 00:48:22,370
something to the DOM, then
something unrelated can

1170
00:48:22,370 --> 00:48:24,040
trigger a compute stop.

1171
00:48:24,040 --> 00:48:26,410
And it just happens as
you render this page.

1172
00:48:26,410 --> 00:48:28,070
So a lot of it's
uncoordinated.

1173
00:48:28,070 --> 00:48:32,320
It's not these little tight, I
mean, they're the tight loop

1174
00:48:32,320 --> 00:48:34,380
things, I think, for painting
and rendering.

1175
00:48:34,380 --> 00:48:37,410
But a lot of people just have
all these components, and then

1176
00:48:37,410 --> 00:48:39,910
some affect the DOM, and
some require reading.

1177
00:48:39,910 --> 00:48:43,430
So I think you see that among
just having a ton of

1178
00:48:43,430 --> 00:48:45,110
stuff on your page.

1179
00:48:45,110 --> 00:48:49,310
PAUL LIST: From my point of
view, the biggest waste of

1180
00:48:49,310 --> 00:48:52,660
time I think I've seen would
be CSS selector matching,

1181
00:48:52,660 --> 00:48:54,400
which is remarkably fast.

1182
00:48:54,400 --> 00:48:58,220
And if you're optimizing your
selectors for matching, that's

1183
00:48:58,220 --> 00:49:01,380
probably not something you're
going to see a return on.

1184
00:49:01,380 --> 00:49:05,480
The thing that I've seen the
most use come from would be

1185
00:49:05,480 --> 00:49:09,260
promoting for isolation, putting
elements onto their

1186
00:49:09,260 --> 00:49:11,360
own layer when they're
frequently painted.

1187
00:49:11,360 --> 00:49:13,240
That's the one I've seen
work the most.

1188
00:49:13,240 --> 00:49:15,950
JOSH PEEK: I agree mostly on the
selector matching stuff,

1189
00:49:15,950 --> 00:49:20,350
but if you look at some really
huge DOMs that have maybe like

1190
00:49:20,350 --> 00:49:23,960
30,000 nodes, and you have just
a buildup of all this

1191
00:49:23,960 --> 00:49:27,560
CSS, and typically people have
so many descendant selectors

1192
00:49:27,560 --> 00:49:29,790
that just target an
anchor element.

1193
00:49:29,790 --> 00:49:34,910
And if you add a ton of anchor
elements in this DOM, that's

1194
00:49:34,910 --> 00:49:35,430
going to add up.

1195
00:49:35,430 --> 00:49:39,130
So it's not like every rule
matters, but there's ones that

1196
00:49:39,130 --> 00:49:40,170
you can call out.

1197
00:49:40,170 --> 00:49:40,410
PAUL LIST: Right.

1198
00:49:40,410 --> 00:49:41,550
No, for sure.

1199
00:49:41,550 --> 00:49:44,060
But I would argue that was a
fairly extreme case, unless

1200
00:49:44,060 --> 00:49:46,470
I'm misunderstanding
your description.

1201
00:49:46,470 --> 00:49:48,860
I think for most people and most
applications where the

1202
00:49:48,860 --> 00:49:50,870
DOM is not 30,000 nodes--

1203
00:49:50,870 --> 00:49:52,740
wow.

1204
00:49:52,740 --> 00:49:54,910
JOSH PEEK: It's GitHub
commit diffs.

1205
00:49:54,910 --> 00:49:56,690
PAUL LIST: Boo.

1206
00:49:56,690 --> 00:49:57,790
ELI FIDLER: We see a lot
of sites that are

1207
00:49:57,790 --> 00:49:58,667
over 100,000 nodes.

1208
00:49:58,667 --> 00:49:59,800
PAUL LIST: Really?

1209
00:49:59,800 --> 00:50:01,210
Wow.

1210
00:50:01,210 --> 00:50:04,080
Just gonna let that
sink in for a bit.

1211
00:50:04,080 --> 00:50:04,870
ANDRE BEHRENS: Jonathan,
I was wondering what

1212
00:50:04,870 --> 00:50:05,930
your experience was.

1213
00:50:05,930 --> 00:50:08,090
JONATHAN KLEIN: Yeah, that's
the-- unfortunately, the big

1214
00:50:08,090 --> 00:50:10,610
wins have been removing content
or removing design

1215
00:50:10,610 --> 00:50:14,110
elements, so removing drop
shadows off of every element

1216
00:50:14,110 --> 00:50:17,090
on the page kind of thing, and
things like getting rid of

1217
00:50:17,090 --> 00:50:18,600
animated carousels.

1218
00:50:18,600 --> 00:50:21,140
Sometimes those things are hard
to pass through because

1219
00:50:21,140 --> 00:50:23,040
the designers or the UX people
really want that.

1220
00:50:23,040 --> 00:50:25,000
But at the end of the day, you
have to test it, right?

1221
00:50:25,000 --> 00:50:28,170
And if people want a jank-free
experience more than they want

1222
00:50:28,170 --> 00:50:30,850
drop shadows, then that's what
you should give them.

1223
00:50:30,850 --> 00:50:32,827
ANDRE BEHRENS: We have a
question from John Mumm.

1224
00:50:32,827 --> 00:50:37,300

1225
00:50:37,300 --> 00:50:37,540
AUDIENCE: Hi.

1226
00:50:37,540 --> 00:50:40,560
We've talked a lot about images
decoding and resizing

1227
00:50:40,560 --> 00:50:42,470
being very expensive.

1228
00:50:42,470 --> 00:50:44,970
Do we know of any example
libraries or example

1229
00:50:44,970 --> 00:50:47,760
implementations that use web
workers and transferable

1230
00:50:47,760 --> 00:50:49,950
objects to have a significant
impact on this?

1231
00:50:49,950 --> 00:50:50,910
PAUL LIST: Oh, dear.

1232
00:50:50,910 --> 00:50:52,320
Yes, now.

1233
00:50:52,320 --> 00:50:55,050
I did do, actually, an
experiment with this one,

1234
00:50:55,050 --> 00:50:57,920
where I actually created canvas
elements for all the

1235
00:50:57,920 --> 00:51:03,830
images and used workers to
decode and resize the images.

1236
00:51:03,830 --> 00:51:06,990
And so you can do it is
the first answer.

1237
00:51:06,990 --> 00:51:09,040
Whether you should do it becomes
the next question.

1238
00:51:09,040 --> 00:51:11,295
And no would be--

1239
00:51:11,295 --> 00:51:11,720
[LAUGHTER]

1240
00:51:11,720 --> 00:51:14,180
PAUL LIST: --because
you have to manage

1241
00:51:14,180 --> 00:51:15,860
all the images yourself.

1242
00:51:15,860 --> 00:51:18,010
Is it in view?

1243
00:51:18,010 --> 00:51:19,530
Is it decoded already?

1244
00:51:19,530 --> 00:51:21,520
Have I decoded this
thing before?

1245
00:51:21,520 --> 00:51:24,240
All these things that the
browser does fantastically

1246
00:51:24,240 --> 00:51:25,830
well for you, you are
now having to

1247
00:51:25,830 --> 00:51:27,890
take care of yourself.

1248
00:51:27,890 --> 00:51:30,120
And you could shoot yourself
in the foot so hard and so

1249
00:51:30,120 --> 00:51:34,320
fast that I feel duty bound to
say you can do it, but don't.

1250
00:51:34,320 --> 00:51:36,560
But you can do it,
and it's cool.

1251
00:51:36,560 --> 00:51:38,510
ELI FIDLER: Especially on
mobile, I think it will

1252
00:51:38,510 --> 00:51:40,330
definitely, definitely
not be a win.

1253
00:51:40,330 --> 00:51:42,960
So even if you can get the
image decoded a couple of

1254
00:51:42,960 --> 00:51:45,410
milliseconds faster, the amount
of time that you're

1255
00:51:45,410 --> 00:51:50,180
gonna be moving pixels around,
saturating your memory bus,

1256
00:51:50,180 --> 00:51:54,080
and the battery impact of
running these web workers at

1257
00:51:54,080 --> 00:51:56,630
the same time is going to be
way, way worse than just

1258
00:51:56,630 --> 00:51:57,720
decoding the images normally.

1259
00:51:57,720 --> 00:51:59,660
PAUL LIST: Right, because
you're gonna spawn a new

1260
00:51:59,660 --> 00:52:00,560
worker, right?

1261
00:52:00,560 --> 00:52:03,700
So you haven't got enough cores
on mobile, probably, to

1262
00:52:03,700 --> 00:52:06,840
support that decision.

1263
00:52:06,840 --> 00:52:09,850
And it's going to be slow
because it's JavaScript.

1264
00:52:09,850 --> 00:52:11,110
But you are in control.

1265
00:52:11,110 --> 00:52:13,760
I mean, you are in
total control.

1266
00:52:13,760 --> 00:52:18,500
So that's the trade off you're
making, control for all that.

1267
00:52:18,500 --> 00:52:19,967
ANDRE BEHRENS: OK, we have
another question from Sergei.

1268
00:52:19,967 --> 00:52:25,220

1269
00:52:25,220 --> 00:52:25,570
AUDIENCE: Hi.

1270
00:52:25,570 --> 00:52:29,060
We had a lot of challenges
explaining network

1271
00:52:29,060 --> 00:52:32,030
performance, basically, the
other side of performance, to

1272
00:52:32,030 --> 00:52:35,410
designers and business people.

1273
00:52:35,410 --> 00:52:37,910
And a lot of rendering
performance, actually, is much

1274
00:52:37,910 --> 00:52:40,890
closer to the product they might
actually understand.

1275
00:52:40,890 --> 00:52:43,660
Do you have any suggestions on
how we organize the process

1276
00:52:43,660 --> 00:52:48,620
for making them understand all
of these other issues?

1277
00:52:48,620 --> 00:52:50,200
ANDRE BEHRENS: Jonathan?

1278
00:52:50,200 --> 00:52:52,020
JONATHAN KLEIN: Yeah, I think
similar to network

1279
00:52:52,020 --> 00:52:53,780
performance, you have to kind
of show it to them, right?

1280
00:52:53,780 --> 00:52:56,140
And, in a lot of cases, it's a
lot easier to see rendering

1281
00:52:56,140 --> 00:52:59,650
performance being problematic,
especially if you have low-end

1282
00:52:59,650 --> 00:53:01,400
devices that you can
show people with.

1283
00:53:01,400 --> 00:53:03,570
So I think it's a question of
getting it in front of them.

1284
00:53:03,570 --> 00:53:05,070
And like you said, it is
closer to the product.

1285
00:53:05,070 --> 00:53:07,010
It's closer to the design
side of things.

1286
00:53:07,010 --> 00:53:09,510
So I think it should be easier
for those people to have it be

1287
00:53:09,510 --> 00:53:10,970
more intuitive.

1288
00:53:10,970 --> 00:53:14,786
But I think demonstration
is the best option.

1289
00:53:14,786 --> 00:53:15,590
ANDRE BEHRENS: Yep.

1290
00:53:15,590 --> 00:53:17,470
ELI FIDLER: I think also demoing
on cellular instead of

1291
00:53:17,470 --> 00:53:20,800
Wi-Fi helps a lot.

1292
00:53:20,800 --> 00:53:23,550
PAUL LIST: If I just demoing on
a constrained device, pick

1293
00:53:23,550 --> 00:53:26,160
one, oh, it looked slow,
it looked fast.

1294
00:53:26,160 --> 00:53:29,140
Which would you rather ship?

1295
00:53:29,140 --> 00:53:32,490
It tends to be pretty easy
then, I think, or easier.

1296
00:53:32,490 --> 00:53:33,490
JONATHAN KLEIN: And then one
thing that was really

1297
00:53:33,490 --> 00:53:36,010
successful for WPO was just
business metrics, right?

1298
00:53:36,010 --> 00:53:37,100
And we have some of
that data now.

1299
00:53:37,100 --> 00:53:39,290
It's starting to come out, like
from Facebook and like

1300
00:53:39,290 --> 00:53:41,970
Etsy, so I think showing that
information is really

1301
00:53:41,970 --> 00:53:46,124
important to say this does
really impact engagement.

1302
00:53:46,124 --> 00:53:47,810
ANDRE BEHRENS: We have a
question from Paul Irish.

1303
00:53:47,810 --> 00:53:55,880

1304
00:53:55,880 --> 00:53:58,920
AUDIENCE: I think I was gonna
mostly ask about the same sort

1305
00:53:58,920 --> 00:54:04,410
of thing, but I'm interested
in ways to communicate what

1306
00:54:04,410 --> 00:54:05,070
the impact--

1307
00:54:05,070 --> 00:54:07,740
because like network
performance, page load time is

1308
00:54:07,740 --> 00:54:09,070
a really easy metric.

1309
00:54:09,070 --> 00:54:11,700
We can track that across
browsers, across different

1310
00:54:11,700 --> 00:54:14,900
connectivity, rendering perf.

1311
00:54:14,900 --> 00:54:17,790
There's not much in the way
of numbers that we can

1312
00:54:17,790 --> 00:54:20,560
demonstrate, say, this is the
impact that I had, or this is

1313
00:54:20,560 --> 00:54:22,070
where our problem's at right
now, where we need to

1314
00:54:22,070 --> 00:54:24,200
bring it down here.

1315
00:54:24,200 --> 00:54:28,290
So do you have any ideas on
making things a bit more

1316
00:54:28,290 --> 00:54:31,830
quantitative, so that management
and clients can

1317
00:54:31,830 --> 00:54:36,590
really see the impact that we
have and then understand that

1318
00:54:36,590 --> 00:54:38,160
there is a problem that
we need to solve

1319
00:54:38,160 --> 00:54:41,610
before we get into it.

1320
00:54:41,610 --> 00:54:42,370
JONATHAN KLEIN: Yeah, that's
a great question, because

1321
00:54:42,370 --> 00:54:44,440
everybody quotes these stats,
like 100 milliseconds on

1322
00:54:44,440 --> 00:54:48,270
Amazon was 1% revenue, but you
can't say 3 frames per second

1323
00:54:48,270 --> 00:54:50,090
was half a percent revenue
or something like that.

1324
00:54:50,090 --> 00:54:52,390
So I think we just have to have
real studies that have

1325
00:54:52,390 --> 00:54:54,640
been done by real companies,
and ideally, companies that

1326
00:54:54,640 --> 00:54:57,100
are in your market.

1327
00:54:57,100 --> 00:54:59,340
So again, it's a tough problem,
but I think we need

1328
00:54:59,340 --> 00:55:01,730
to have more people doing
experiments, and be willing to

1329
00:55:01,730 --> 00:55:04,230
slow down half their traffic
to 30 frames per second and

1330
00:55:04,230 --> 00:55:04,880
see what happens.

1331
00:55:04,880 --> 00:55:05,320
PAUL LIST: Right.

1332
00:55:05,320 --> 00:55:07,940
I mean, we are now at the point
where the browser is

1333
00:55:07,940 --> 00:55:11,890
capable of 60 frames a second,
which hasn't always been true.

1334
00:55:11,890 --> 00:55:15,150
But now that it is, we're sort
of playing catch up with the

1335
00:55:15,150 --> 00:55:17,120
page load time part
of performance.

1336
00:55:17,120 --> 00:55:20,750
And now we need to ask that
question, and say, as an

1337
00:55:20,750 --> 00:55:23,710
industry, as a body of
developers, we are interested,

1338
00:55:23,710 --> 00:55:27,100
I hope, in seeing how the actual
runtime experience

1339
00:55:27,100 --> 00:55:31,490
affects our users and how much
it affects our users.

1340
00:55:31,490 --> 00:55:33,990
Because we don't know today is
it the same, is it less, is it

1341
00:55:33,990 --> 00:55:35,810
more than the page load time?

1342
00:55:35,810 --> 00:55:39,570
Because they load once,
hopefully, and run

1343
00:55:39,570 --> 00:55:41,430
it for a long time.

1344
00:55:41,430 --> 00:55:44,230
So 100 milliseconds is different
on rendering for

1345
00:55:44,230 --> 00:55:48,830
page load is a very different
deal to repeatedly hitting

1346
00:55:48,830 --> 00:55:49,680
them with 100 milliseconds.

1347
00:55:49,680 --> 00:55:52,680
But we don't know
how big that is.

1348
00:55:52,680 --> 00:55:57,040
So yeah, we don't have a good
answer, I don't think, on how

1349
00:55:57,040 --> 00:55:58,680
much it affects the
bottom line.

1350
00:55:58,680 --> 00:56:00,878
But I think we need to find
out, and pretty quickly.

1351
00:56:00,878 --> 00:56:03,510

1352
00:56:03,510 --> 00:56:03,726
ANDRE BEHRENS: All right.

1353
00:56:03,726 --> 00:56:05,720
I think that about wraps
it up for us.

1354
00:56:05,720 --> 00:56:08,060
Are we ready for lunch?

1355
00:56:08,060 --> 00:56:11,050

1356
00:56:11,050 --> 00:56:12,525
Oh, someone has a microphone
ready to go?

1357
00:56:12,525 --> 00:56:12,810
AUDIENCE: Yeah.

1358
00:56:12,810 --> 00:56:13,590
ANDRE BEHRENS: Oh,
that's fine.

1359
00:56:13,590 --> 00:56:15,170
AUDIENCE: One question.

1360
00:56:15,170 --> 00:56:17,490
Actually, my biggest problem
with rendering performance is

1361
00:56:17,490 --> 00:56:20,440
that I cannot describe my
intent to the browser.

1362
00:56:20,440 --> 00:56:24,320
I cannot describe my intent that
I want this element to

1363
00:56:24,320 --> 00:56:27,100
have higher priority when
rendered over another.

1364
00:56:27,100 --> 00:56:29,320
And I think that's the biggest
problem for me when we're

1365
00:56:29,320 --> 00:56:31,230
talking rendering performance,
that the browser is making

1366
00:56:31,230 --> 00:56:34,530
false assumptions of what my
intent is in my layout.

1367
00:56:34,530 --> 00:56:36,330
And I think this goes together
with images.

1368
00:56:36,330 --> 00:56:38,960
This image should be rendered
before that.

1369
00:56:38,960 --> 00:56:42,500
This box should be rendered
before this box.

1370
00:56:42,500 --> 00:56:45,020
What are we doing to look into
that so I, as a developer, can

1371
00:56:45,020 --> 00:56:47,140
declare my intent to the
browser, so the browser can

1372
00:56:47,140 --> 00:56:50,030
make, or the rendering agent,
can make a more intelligent

1373
00:56:50,030 --> 00:56:54,320
guess of how things should be
composed when layouting?

1374
00:56:54,320 --> 00:56:56,920
Because now we're talking
about translateZ.

1375
00:56:56,920 --> 00:56:59,060
That is, to me, like a hack.

1376
00:56:59,060 --> 00:57:01,700
First of all, it's not hardware,
forcing hardware

1377
00:57:01,700 --> 00:57:03,470
extortion in IE.

1378
00:57:03,470 --> 00:57:06,050
And I, as a developer, I should
know about layers.

1379
00:57:06,050 --> 00:57:09,030
That's a implementation detail
in the rendering engine.

1380
00:57:09,030 --> 00:57:13,120
I just want to declare my intent
that this layer is

1381
00:57:13,120 --> 00:57:16,640
either higher or lower priority,
and then you guys

1382
00:57:16,640 --> 00:57:17,910
should figure out the rest.

1383
00:57:17,910 --> 00:57:20,170
Are we looking into
these things?

1384
00:57:20,170 --> 00:57:21,650
Is there any proposals
coming up?

1385
00:57:21,650 --> 00:57:28,380

1386
00:57:28,380 --> 00:57:31,940
PAUL LIST: So there's
one, yeah.

1387
00:57:31,940 --> 00:57:35,450
OK, first of all, the browser
should do everything for me is

1388
00:57:35,450 --> 00:57:39,150
one thing I'd wanna
pick up on.

1389
00:57:39,150 --> 00:57:40,330
I don't know how much
I agree with that.

1390
00:57:40,330 --> 00:57:41,580
I don't think I agree
with that.

1391
00:57:41,580 --> 00:57:43,870

1392
00:57:43,870 --> 00:57:45,660
The way I would normally phrase
this is if you write

1393
00:57:45,660 --> 00:57:49,330
spec compliant code, you should
expect spec compliant

1394
00:57:49,330 --> 00:57:51,120
responses from the browser.

1395
00:57:51,120 --> 00:57:52,870
But there is no promise
of performance.

1396
00:57:52,870 --> 00:57:54,110
Now, the promise comes
through the fact that

1397
00:57:54,110 --> 00:57:55,440
everybody wants fast code.

1398
00:57:55,440 --> 00:57:59,830
Browser vendors want to give you
fast implementations, and

1399
00:57:59,830 --> 00:58:02,710
so that's something you should
seek, and you should ask for,

1400
00:58:02,710 --> 00:58:04,760
and you should push
for, definitely.

1401
00:58:04,760 --> 00:58:09,270
But I think it's very difficult
to hand-on-heart say

1402
00:58:09,270 --> 00:58:12,670
a developer, any programmer
should be completely divorced

1403
00:58:12,670 --> 00:58:14,200
from the system they're
programming on.

1404
00:58:14,200 --> 00:58:16,500
I can't quite bring myself
to say that.

1405
00:58:16,500 --> 00:58:20,900
I think it would be a nice
thing, but I don't think

1406
00:58:20,900 --> 00:58:22,670
that's realistic.

1407
00:58:22,670 --> 00:58:25,270
Is that something that we
are looking to improve?

1408
00:58:25,270 --> 00:58:25,780
Yeah, always.

1409
00:58:25,780 --> 00:58:27,020
I think there's always
a definite

1410
00:58:27,020 --> 00:58:29,830
balancing act of APIs.

1411
00:58:29,830 --> 00:58:32,340
If they're overly prescriptive
and you don't get enough

1412
00:58:32,340 --> 00:58:34,930
control, then you end up with
what I think is the outcast

1413
00:58:34,930 --> 00:58:37,340
situation where you can't
polyfill it, you

1414
00:58:37,340 --> 00:58:38,820
can't bridge that gap.

1415
00:58:38,820 --> 00:58:41,490

1416
00:58:41,490 --> 00:58:45,210
At least if it's too difficult
or it's a horrible API--

1417
00:58:45,210 --> 00:58:48,360
and I would argue that things
like WebGL actually are very,

1418
00:58:48,360 --> 00:58:50,690
very horrible, from a
developer's point of view.

1419
00:58:50,690 --> 00:58:51,940
But at least you can
polyfill that.

1420
00:58:51,940 --> 00:58:54,860
You can at least add on
something like 3JS.

1421
00:58:54,860 --> 00:58:57,210
So I'd rather it was
that way around.

1422
00:58:57,210 --> 00:59:00,770
But it comes through developer
feedback, saying we don't

1423
00:59:00,770 --> 00:59:03,500
think this works, we
don't like this.

1424
00:59:03,500 --> 00:59:07,240
ANDRE BEHRENS: OK, and I think
that is really it.

1425
00:59:07,240 --> 00:59:22,103
[APPLAUSE]